---
title: "EWAS_of_COAD_DH_Data_set"
author: "Alos Diallo"
date: "2024-11-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# =========================================================================

# EWAS - COAD DH Dataset

# Code by: Alos Diallo

# 2023,2024

# =========================================================================

Loading libraries:

```{r message=FALSE, warning=FALSE, include=FALSE}
library(minfi)
library(sesame)
library(pheatmap)
library(minfiData)
library(FlowSorted.Blood.EPIC)
library(HiTIMED)
library(ggplot2)
library(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
library(IlluminaHumanMethylationEPICv2manifest)
library(IlluminaHumanMethylationEPICv2anno.20a1.hg38)
library(IlluminaHumanMethylationEPICmanifest)
library(limma)
library(qvalue)
library(sva)
library(ENmix)
library(ggplot2)
library(ggrepel)
library(matrixStats)
library(EpiDISH)
library(tibble)
library(tidyr)
library(dplyr)
library(methylGSA)
```

Loading the annotation file:

```{r}
data("IlluminaHumanMethylationEPICanno.ilm10b4.hg19")
anno <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
load("/Users/adiallo/Desktop/Dartmouth/Christiansen_lab/CF_Project/Methylation/Annotation/EPIC.hg19.manifest.RDATA")
attach(annotation)
manifest <- getManifest(IlluminaHumanMethylationEPICmanifest)

```

Loading the data and metadata information

```{r}
targets <- read.csv("/Users/adiallo/Desktop/Thesis/Data_Documents/dm_57_samples.csv")
targets$patient <- paste(targets$Sentrix_ID,targets$Sentrix_Position,sep="_")
rownames(targets) <- targets$patient
targets$SampleID<- targets$patient

targets_expanded <- read.csv("/Users/adiallo/Desktop/Thesis/Data_Documents/data_all.csv")
targets_expanded$patient <- paste(targets$Sentrix_ID,targets$Sentrix_Position,sep="_")
rownames(targets_expanded) <- targets_expanded$patient
targets_expanded$SampleID<- targets_expanded$patient
targets = targets_expanded
```

```{r}
idat = "/Users/adiallo/Desktop/Thesis/Data_Documents/All_Data/DNA_Methylation/dm_data/no_match/"
RGset_32 = read.metharray.exp("/Users/adiallo/Desktop/Thesis/Data_Documents/All_Data/DNA_Methylation/dm_data/no_match/idats/",recursive = TRUE) 
#RGset_25 = openSesame(idat , func = getBetas) 
RGset_25 = read.metharray.exp("/Users/adiallo/Desktop/Thesis/Data_Documents/All_Data/DNA_Methylation/dm_data/no_match/25_samples/",recursive = TRUE) 
```

Looking for bad CpG's using QCinfo

```{r}
sva32<-ctrlsva(RGset_32)
sva25<-ctrlsva(RGset_25)
SVA_combined <- rbind(sva25[,1:8], sva32)
SVA_combined_df <- as.data.frame(SVA_combined)

surrogateVariables <- sva
# Convert RGChannelSet to RGChannelSetExtended
RGset_32_extended <- read.metharray.exp("/Users/adiallo/Desktop/Thesis/Data_Documents/All_Data/DNA_Methylation/dm_data/no_match/idats/",recursive = TRUE,extended = TRUE)
RGset_25_extended <- read.metharray.exp("/Users/adiallo/Desktop/Thesis/Data_Documents/All_Data/DNA_Methylation/dm_data/no_match/25_samples/",recursive = TRUE,extended = TRUE) 

# Run QCinfo function
qc_info32 <- QCinfo(RGset_32_extended)
qc_info25 <- QCinfo(RGset_25_extended)

# Display QC information
#print(qc_info32)
#print(qc_info25)
badCpG = c(qc_info32$badCpG,qc_info25$badCpG)
# Remove any suffix after an underscore
cleaned_badCpG <- sub("_.*", "", badCpG)
```

Normalizing

```{r}
Noob_25_m = preprocessNoob(RGset_25)
Noob_32_m = preprocessNoob(RGset_32)
```

Extracting the beta values from the normalized samples. I am now running functional normalization as it contains a Noob option

```{r}
Betas_25<-getBeta(Noob_25_m)
Betas_32<-getBeta(Noob_32_m)
```

Colapsing the betas so that the data can be merged

```{r}
Betas_25<- sesame::betasCollapseToPfx(Betas_25)
colnames(Betas_25) = colnames(Noob_25_m)
```

Filter out sex linked probes

```{r}
# Extract probes located on the Y chromosome
cpg_y_probes <- rownames(anno[anno$chr == "chrY", ])  # Filter probes on Y chromosome

# Filter Y chromosome probes from Betas_25
cpg_y_probes_in_betas_25 <- cpg_y_probes[cpg_y_probes %in% rownames(Betas_25)]
Betas_25_filtered <- Betas_25[!rownames(Betas_25) %in% cpg_y_probes_in_betas_25, ]

# Filter Y chromosome probes from Betas_32
cpg_y_probes_in_betas_32 <- cpg_y_probes[cpg_y_probes %in% rownames(Betas_32)]
Betas_32_filtered <- Betas_32[!rownames(Betas_32) %in% cpg_y_probes_in_betas_32, ]

# Extract probes located on the X chromosome
cpg_x_probes <- rownames(anno[anno$chr == "chrX", ])

# Filter X chromosome probes from Betas_25
cpg_x_probes_in_betas_25 <- cpg_x_probes[cpg_x_probes %in% rownames(Betas_25_filtered)]
Betas_25_filtered <- Betas_25_filtered[!rownames(Betas_25_filtered) %in% cpg_x_probes_in_betas_25, ]

# Filter X chromosome probes from Betas_32
cpg_x_probes_in_betas_32 <- cpg_x_probes[cpg_x_probes %in% rownames(Betas_32_filtered)]
Betas_32_filtered <- Betas_32_filtered[!rownames(Betas_32_filtered) %in% cpg_x_probes_in_betas_32, ]
```

Merging the samples

```{r}
# Ensure the same probes exist in both datasets
common_probes <- intersect(rownames(Betas_25_filtered), rownames(Betas_32_filtered))

# Subset both datasets to include only common probes
Betas_25_filtered <- Betas_25_filtered[common_probes, ]
Betas_32_filtered <- Betas_32_filtered[common_probes, ]

# Combine the beta values from both datasets
DH_CRC_Betas <- cbind(Betas_25_filtered, Betas_32_filtered) 

```

Running HiTIMED to generate cell type proportions

```{r}
HiTIMED_result<-HiTIMED_deconvolution(DH_CRC_Betas,"COAD",6,"tumor")
```

Running EpiDISH to obtain fibroblast proportions

```{r}
# Define the beta matrix and reference matrix
beta_matrix <- DH_CRC_Betas  # Your dataset
ref_matrix <- centEpiFibIC.m  # Reference matrix for EpiDISH (e.g., centEpiFibIC.m)

# Run EpiDISH
epidish_results <- epidish(beta.m = beta_matrix, ref.m = ref_matrix, method = "RPC")

# Extract the estimated cell type proportions
cell_type_proportions <- epidish_results$estF

# Convert the matrix to a data frame and scale proportions to percentages
cell_type_proportions_df <- as.data.frame(cell_type_proportions) * 100

# Add SampleID as a column from the row names
cell_type_proportions_df$SampleID <- rownames(cell_type_proportions)

# Inspect the results
head(cell_type_proportions_df)
```

Examining Variance and limiting the dataset size

```{r}
# Assuming beta_matrix is a dataframe or matrix where rows are CpG sites and columns are samples

# Calculate variances for each CpG site
variances <- apply(DH_CRC_Betas, 1, var)

# Check summary statistics for variances
summary(variances)

# Create histogram of variances
hist(variances, breaks = 1000, main = "Variance Distribution of CpG Sites",
     xlab = "Variance", ylab = "Frequency", col = "skyblue")

# Add a vertical line for a tentative cutoff
abline(v = 0.005, col = "red", lwd = 2, lty = 2)

# Define the threshold for variance
threshold <- 0.01

# Count the number of CpG sites with variance greater than the threshold
num_above_threshold <- sum(variances > threshold)

# Print the result
cat("Number of CpG sites with variance > ", threshold, ": ", num_above_threshold, "\n")

# Proportion of CpGs retained
prop_retained <- num_above_threshold / length(variances)
cat("Proportion of CpG sites retained: ", round(prop_retained * 100, 2), "%\n")

# Count the number of CpG sites with variance <= threshold (to the left of the line)
num_below_threshold <- sum(variances <= threshold)

# Print the result
cat("Number of CpG sites with variance <= ", threshold, ": ", num_below_threshold, "\n")

temp = DH_CRC_Betas

# Recalculate logical indices
low_variance_indices <- variances <= threshold

#DH_CRC_Betas <- DH_CRC_Betas[low_variance_indices, ]

```

Generate M values

```{r}
DH_CRC_M_value = BetaValueToMValue(DH_CRC_Betas)
```

Filter out bad CpG's

```{r}
# Identify good CpGs
all_cpgs <- rownames(DH_CRC_M_value)
good_cpgs <- setdiff(all_cpgs, cleaned_badCpG)
# Filter the M values to keep only good CpGs
filtered_DH_CRC_M_value <- DH_CRC_M_value[good_cpgs, ]
DH_CRC_M_value = filtered_DH_CRC_M_value
```

```{r}
# Step 1: Prepare Combined Data
HiTIMED_result$SampleID <- rownames(HiTIMED_result)
SVA_combined_df$SampleID <- rownames(SVA_combined_df)

# Merge HiTIMED results, targets, and EpiDISH fibroblast data
combined_data <- HiTIMED_result %>%
  left_join(targets, by = "SampleID") %>%
  left_join(cell_type_proportions_df %>% dplyr::select(SampleID, Fib), by = "SampleID") %>%
  left_join(SVA_combined_df, by = 'SampleID')  

# Step 2: Filter out Rectal Samples
combined_data_filtered <- combined_data %>%
  filter(site != "rectum")

# Subset M-value matrix to exclude rectal samples
DH_CRC_M_value_filtered <- DH_CRC_M_value[, combined_data_filtered$SampleID]

# Step 3: Normalize Metadata Columns
combined_data_filtered <- combined_data_filtered %>%
  mutate(
    site = tolower(gsub(" ", "", site)),
    across(c("sex", "any_mets", "MLH1", "Distant_Mets", "ln_only", "node_stage"), as.factor),  
    age = as.numeric(as.character(age))  
  )

# Step 4: Define Relevant Columns for Analysis
relevant_columns <- c("SampleID", "MLH1", "Tumor", "Endothelial", "Epithelial", "Fib", 
                      "CD8mem", "Bmem", "DC", "Treg", "CD4mem", "age", "sex", 
                      "any_mets", "Distant_Mets", "ln_only", "node_stage",
                      "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8")

analysis_data <- combined_data_filtered %>%
  dplyr::select(all_of(relevant_columns)) %>%
  column_to_rownames(var = "SampleID")  

# Check for NA values
if (sum(is.na(analysis_data)) > 0) {
  stop("NA values detected in analysis_data. Please investigate.")
}

# ----------------------------------------------------
# (Steps 1–4 remain the same for preparing combined_data,
# filtering, and obtaining analysis_data and DH_CRC_M_value_filtered)
# ----------------------------------------------------

# ----------------------------------------------------
# Step 5: Create Design Matrices
# ----------------------------------------------------
adjusted_design <- model.matrix(
  ~ any_mets + age + sex + MLH1 + Tumor + Endothelial + Epithelial + Fib + Treg + 
    CD4mem + CD8mem + Bmem + DC, data = analysis_data)

unadjusted_design <- model.matrix(
  ~ any_mets + MLH1 + age + sex + Tumor, data = analysis_data)

colnames(adjusted_design) <- make.names(colnames(adjusted_design), unique = TRUE)
colnames(unadjusted_design) <- make.names(colnames(unadjusted_design), unique = TRUE)

# ----------------------------------------------------
# Step 6: Fit Models
# ----------------------------------------------------
fit_adjusted   <- eBayes(lmFit(DH_CRC_M_value_filtered, adjusted_design))
fit_unadjusted <- eBayes(lmFit(DH_CRC_M_value_filtered, unadjusted_design))

# ----------------------------------------------------
# Step 7: Use a More Stringent Raw P-value Threshold
# ----------------------------------------------------
# e.g., p < 1e-3 (you can adjust as needed)
sig_threshold <- 1e-3

adjusted_results   <- topTable(fit_adjusted, coef = "any_metsTRUE", adjust.method = "none", n = Inf)
unadjusted_results <- topTable(fit_unadjusted, coef = "any_metsTRUE", adjust.method = "none", n = Inf)

# Keep only probes common to both models
common_probes <- intersect(rownames(adjusted_results), rownames(unadjusted_results))
adjusted_results   <- adjusted_results[common_probes, ]
unadjusted_results <- unadjusted_results[common_probes, ]

# Identify significant CpGs based on raw p < sig_threshold
sig_adjusted   <- rownames(adjusted_results[adjusted_results$P.Value < sig_threshold, ])
sig_unadjusted <- rownames(unadjusted_results[unadjusted_results$P.Value < sig_threshold, ])

cat("Number of significant CpGs in adjusted model (p < ", sig_threshold, "): ", length(sig_adjusted), "\n")
cat("Number of significant CpGs in unadjusted model (p < ", sig_threshold, "): ", length(sig_unadjusted), "\n")

# ----------------------------------------------------
# NEW Correct Categorization Logic
# ----------------------------------------------------
# Default all probes as "Not Significant"
adjusted_results$category <- "Not Significant"

# Label those significant in both models as "Shared"
both_sig <- intersect(sig_adjusted, sig_unadjusted)
adjusted_results$category[rownames(adjusted_results) %in% both_sig] <- "Shared"

# Label those only significant in the adjusted model as "Lost in Unadjusted Model"
lost_sig <- setdiff(sig_adjusted, sig_unadjusted)
adjusted_results$category[rownames(adjusted_results) %in% lost_sig] <- "Lost in Unadjusted Model"

# Label those only significant in the unadjusted model as "Gained in Unadjusted Model"
gained_sig <- setdiff(sig_unadjusted, sig_adjusted)
adjusted_results$category[rownames(adjusted_results) %in% gained_sig] <- "Gained in Unadjusted Model"

# ----------------------------------------------------
# Step 8: Merge with Annotation and Add Gene Labels
# ----------------------------------------------------
# Merge with the full annotation 'anno' (which has columns 'Name' and 'UCSC_RefGene_Name')
volcano_data <- merge(adjusted_results, anno, by.x = "row.names", by.y = "Name")
colnames(volcano_data)[1] <- "probe"

# Calculate -log10(p-value) for plotting
volcano_data$logPval <- -log10(volcano_data$P.Value)

# Now add a column 'Gene' that extracts the first gene from the UCSC_RefGene_Name field.
volcano_data$Gene <- sapply(strsplit(as.character(volcano_data$UCSC_RefGene_Name), ";"), `[`, 1)

# ----------------------------------------------------
# Step 9: Create the Volcano Plot with ggplot2
# ----------------------------------------------------
library(ggplot2)
library(ggrepel)

volcano_plot <- ggplot(volcano_data, aes(x = logFC, y = logPval, color = category)) +
  geom_point(alpha = 0.5) +
  scale_color_manual(values = c("Not Significant" = "gray",
                                "Shared" = "blue", 
                                "Lost in Unadjusted Model" = "red", 
                                "Gained in Unadjusted Model" = "green")) +
  theme_minimal() +
  labs(title = paste0("Volcano Plot (p < ", sig_threshold, " threshold)"), 
       x = "Log Fold Change", 
       y = "-log10(p-value)", 
       color = "CpG Status") +
  # Label only points meeting criteria (e.g. P.Value < 1e-6 and |logFC| > 1)
geom_text_repel(
  data = subset(volcano_data, category != "Not Significant" & P.Value < 1e-3),
  aes(label = Gene),
  size = 3,
  max.overlaps = 10
)

print(volcano_plot)


```

GO and Pathway analysis for adjusted model. Hallmarks of Cancer

```{r}
# 1) Order CpG sites by p-value (smallest to largest)
top_100_cpg <- adjusted_results %>%
  arrange(P.Value) %>%   # Sort by p-value (ascending)
  head(2000)              # Keep the top 100 CpG sites

# 2) Extract CpG site names and p-values
cpg_sites <- rownames(top_100_cpg)      # Get the CpG site names
p_values  <- top_100_cpg$P.Value        # Get corresponding p-values

# 2.5) Create a named vector for methylGSA
cpg_pval <- setNames(p_values, cpg_sites)

library(dplyr)
library(msigdbr)

h_gene_sets_df = msigdbr(species = "human", category = "H")

# If your methylation annotation uses gene SYMBOL:
hallmark_symbol_list <- h_gene_sets_df %>%
  group_by(gs_name) %>%
  summarize(genes = list(unique(gene_symbol)), .groups = "drop") %>%
  # Convert to a named list
  pull(genes) %>%
  setNames(h_gene_sets_df %>% distinct(gs_name) %>% pull(gs_name))

# If your methylation annotation uses ENTREZ IDs:

hallmark_entrez_list <- h_gene_sets_df %>%
  group_by(gs_name) %>%
  summarize(genes = list(unique(as.character(entrez_gene))), .groups = "drop") %>%
  pull(genes) %>%
  setNames(unique(h_gene_sets_df$gs_name))

library(methylGSA)
hallmark_results_methylGSA <- methylglm(
  cpg.pval  = cpg_pval,
  array.type = "EPIC",             # or "450K"
  group      = "all",              # or "body"/"promoter1"/"promoter2"
  GS.list    = hallmark_entrez_list,  # <--- your custom list here
  GS.idtype  = "ENTREZID",            # must match how your hallmark list is stored
  minsize    = 100,
  maxsize    = 500,
  parallel   = FALSE
  # Notice: we do NOT use GS.type here.
)

head(hallmark_results_methylGSA)
library(ggplot2)
library(dplyr)

# Select the top 5 significant terms (sorted by p-value)
top_terms <- hallmark_results_methylGSA %>%
  arrange(pvalue) %>%
  head(15)

# Convert ID to factor with ordered levels for proper sorting
top_terms$ID <- factor(top_terms$ID, levels = rev(top_terms$ID))

# Create a ggplot barplot
ggplot(top_terms, aes(x = ID, y = Size, fill = pvalue)) +
  geom_bar(stat = "identity") +
  scale_fill_gradient(low = "blue", high = "red") +  # Color by p-value (red = more significant)
  coord_flip() +  # Flip for Enrichr-style horizontal bars
  labs(x = "", y = "Size", title = "Top 5 Enriched Hallmark Pathways (methylGSA)") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        plot.title = element_text(size = 14, face = "bold"))


head(hallmark_results_methylGSA, n =20)
```

Don't use as this is not Hallmark
```{r}

# -----------------------------
# GSEA for the Adjusted Results
# -----------------------------

# # 1) Extract CpG sites and p-values from the rownames and columns
cpg_sites <- rownames(adjusted_results)     # row names of adjusted_results
p_values  <- adjusted_results$P.Value       # the raw p-values (or adjusted if you wish)
# 
# # 2) Create a named vector for methylGSA
cpg_pval <- setNames(p_values, cpg_sites)
# 

#Don't use this as the DB is not really helpful here.
# # 3) Run methylGSA (Gene Ontology as an example)
# go_results_methylGSA <- methylglm(
#   cpg.pval  = cpg_pval,
#   array.type = "EPIC",   # or "450K" if your data is from 450K
#   group = "all",
#   GS.type = "GO",        # Choose "GO", "KEGG", or "Reactome"
#   minsize = 100,
#   maxsize = 500,
#   parallel = FALSE
# )
# 
# # Check the top results
# head(go_results_methylGSA)
# 
# # Optionally display top 10 terms as a nice table
# library(kableExtra)
# go_results_methylGSA %>%
#   arrange(pvalue) %>%
#   head(20) %>%
#   kable(caption = "Top Enriched GO Terms (Adjusted Model)") %>%
#   kable_styling(full_width = FALSE)

# ----------------------------------------
# GSEA for the Adjusted Results (KEGG)
# ----------------------------------------
kegg_results_methylGSA <- methylglm(
  cpg.pval  = cpg_pval,
  array.type = "EPIC",
  group = "all",
  GS.type = "KEGG",
  minsize = 100,
  maxsize = 500,
  parallel = FALSE
)

library(kableExtra)

kegg_results_methylGSA %>%
  arrange(pvalue) %>%
  head(40) %>%
  kable(caption = "Top Enriched KEGG Pathways (Adjusted Model)") %>%
  kable_styling(full_width = FALSE)
```

```{r}
#########################################
# Complete Code to Generate a Manhattan Plot
#########################################

# 1) Load Required Libraries
library(dplyr)
library(tibble)
library(qqman)

# 2) Set Thresholds
sig_threshold <- 1e-3       # p-value threshold
logFC_threshold <- 1        # absolute logFC threshold

# -------------------------------
# 3) Prepare Adjusted EWAS Results
# -------------------------------
# Assuming 'adjusted_results' is a data frame or matrix returned by topTable().
# Typically, row names hold the probe IDs. We'll move them into a column called 'probe'.

adjusted_results$probe <- rownames(adjusted_results)

adjusted_results <- adjusted_results %>%
  mutate(Significance = case_when(
    P.Value < sig_threshold & abs(logFC) >= logFC_threshold ~ "Significant",
    TRUE ~ "Not Significant"
  ))

# Quick check of the new Significance column
table(adjusted_results$Significance)

# ----------------------------------------------------
# 4) Merge Adjusted Results with Annotation
# ----------------------------------------------------
# 'anno' should have columns: Name, chr, pos
# We'll match 'probe' in adjusted_results to 'Name' in anno.

manhattan_data <- merge(
  as.data.frame(adjusted_results),
  as.data.frame(anno),
  by.x = "probe",  # merges on 'probe'
  by.y = "Name",   # merges on 'Name' in annotation
  all.x = TRUE     # keep all EWAS results even if some annotation is missing
)

# ----------------------------------------------------
# 5) (Optional) Handle Duplicate Probes
# ----------------------------------------------------
# If you have duplicates (rare, but can happen), keep the first or the lowest p-value, etc.
manhattan_data <- manhattan_data[!duplicated(manhattan_data$probe), ]

# ----------------------------------------------------
# 6) Prepare Columns for qqman
# ----------------------------------------------------
# qqman::manhattan() requires columns named "CHR", "BP", "SNP", and "P".

# Convert chromosome from e.g. "chr1" to numeric 1
# (remove 'chr' prefix). Exclude non-numeric chromosomes if present.
manhattan_data$CHR <- as.numeric(gsub("chr", "", manhattan_data$chr))
manhattan_data <- manhattan_data[!is.na(manhattan_data$CHR), ]

# Rename 'pos' -> 'BP', 'probe' -> 'SNP', 'P.Value' -> 'P'
names(manhattan_data)[names(manhattan_data) == "pos"]    <- "BP"
names(manhattan_data)[names(manhattan_data) == "probe"] <- "SNP"
names(manhattan_data)[names(manhattan_data) == "P.Value"] <- "P"

# Ensure BP and P are numeric
manhattan_data$BP <- as.numeric(manhattan_data$BP)
manhattan_data$P  <- as.numeric(manhattan_data$P)

# Remove rows with NA p-values
manhattan_data <- manhattan_data[!is.na(manhattan_data$P), ]

# ----------------------------------------------------
# 7) (Optional) Create a Vector of "Significant" Probes
# ----------------------------------------------------
significant_probes <- manhattan_data$SNP[manhattan_data$Significance == "Significant"]

# ----------------------------------------------------
# 8) Generate the Manhattan Plot
# ----------------------------------------------------
# The 'highlight' argument can color certain SNPs (probes) differently (default is red).
# 'annotateTop' and 'annotatePval' let qqman label the points above a p-value threshold.

manhattan(
  manhattan_data,
  chr = "CHR",
  bp = "BP",
  snp = "SNP",     # now holds the CpG name
  p = "P",
  col = c("orchid3", "plum2","#a6bddb", "#3690c0"),  # or any two colors you prefer
  genomewideline = -log10(1e-4),  # draws a line at p=1e-6
  suggestiveline = -log10(1e-3),  # draws a line at p=1e-5
  main = "EWAS Manhattan Plot",
  annotateTop = FALSE,     # label top hits
  annotatePval = 1e-4,    # only label hits with p < 1e-5
  ylim = c(0,5.5)         # optional y-axis limit
)
```

Volcano plot using the same data:

```{r}
library(EnhancedVolcano)

sig_cpgs <- manhattan_data$SNP[
  manhattan_data$P < 1e-4 
]


EnhancedVolcano(manhattan_data,
    lab = manhattan_data$SNP,   # Use the CpG IDs as labels (or substitute with gene names if available)
    x = 'logFC',
    y = 'P',
    pCutoff = 1e-4,             # p-value threshold
    FCcutoff = 1,               # Fold change cutoff
    xlim = c(-2, 2),
    ylim = c(0, 6.5),
    selectLab = sig_cpgs,   
    title = 'EWAS Volcano Plot',
    subtitle = 'p < 1e-4 & |logFC| > 1',
    caption = 'Enhanced Volcano Plot',
    legendLabels = c('NS', 'Log2FC', 'p-value', 'p-value & Log2FC'),
    legendPosition = 'right',
    col = c("gray", "blue", "red", "green")
)
```

```{r}
##############################
# 0) Load Required Libraries
##############################
library(dplyr)
library(kableExtra)

##############################
# 1) Merge EWAS + Annotation
##############################
# 'adjusted_results' has row names = CpG IDs, columns: logFC, P.Value, etc.
# 'anno' has columns: Name, UCSC_RefGene_Name, etc.
# We'll merge by matching CpG row names to 'Name' in anno.

# Move CpG IDs into a column named 'probe'
adjusted_results$probe <- rownames(adjusted_results)

volcano_data <- merge(
  as.data.frame(adjusted_results), 
  as.data.frame(anno), 
  by.x = "probe",   # merges on 'probe' in adjusted_results
  by.y = "Name",    # merges on 'Name' in anno
  all.x = TRUE      # keep all CpGs even if some annotation is missing
)

# Extract the first gene from UCSC_RefGene_Name if multiple are listed with semicolons
volcano_data$Gene <- sapply(
  strsplit(as.character(volcano_data$UCSC_RefGene_Name), ";"),
  `[`,
  1
)

########################################
# 2) Classify CpGs as Hyper or Hypo
########################################
volcano_data <- volcano_data %>%
  mutate(direction = case_when(
    logFC > 0 ~ "Hyper",
    logFC < 0 ~ "Hypo",
    TRUE      ~ "Neutral"   # covers logFC == 0 if any
  ))

# (Optional) If you'd like only significant CpGs, you can also filter by p-value, e.g.
# filter(P.Value < 1e-3) %>%
#   before the top-20 selection.

########################################################
# 3) Select Top 20 Hyper-Methylated by Ascending P-value
########################################################
hyper_top20 <- volcano_data %>%
  filter(direction == "Hyper") %>%
  arrange(P.Value) %>%
  slice_head(n = 20)

########################################################
# 4) Select Top 20 Hypo-Methylated by Ascending P-value
########################################################
hypo_top20 <- volcano_data %>%
  filter(direction == "Hypo") %>%
  arrange(P.Value) %>%
  slice_head(n = 20)

#####################################
# 5) Print Tables with Gene Names
#####################################
# We'll display 'Gene' (falling back to 'probe' if the gene is missing),
# plus logFC, P.Value, etc. Adjust columns as you like.

# Top 20 Hyper-Methylated Table
hyper_top20 %>%
  mutate(Identifier = ifelse(is.na(Gene) | Gene == "", probe, Gene)) %>%
  select(Identifier, probe, logFC, P.Value, direction) %>%
  kable("html", caption = "Top 20 Hyper-Methylated CpGs (by p-value)") %>%
  kable_styling(full_width = FALSE)

# Top 20 Hypo-Methylated Table
hypo_top20 %>%
  mutate(Identifier = ifelse(is.na(Gene) | Gene == "", probe, Gene)) %>%
  select(Identifier, probe, logFC, P.Value, direction) %>%
  kable("html", caption = "Top 20 Hypo-Methylated CpGs (by p-value)") %>%
  kable_styling(full_width = FALSE)
```

```{r}
###############################################################
# Compare GO/KEGG Terms Across 10 Incremental Covariate Models
###############################################################

# 1) Load necessary libraries
# (Install if not already installed)
# install.packages(c("limma", "methylGSA", "wordcloud2", "tidyverse", "kableExtra"))

library(limma)
library(methylGSA)
library(wordcloud2)
library(tidyverse)
library(kableExtra)

##############################################################################
# 2) Define the list of models (one covariate added in each step)
##############################################################################
# Model 1)  Base: any_mets + MLH1 + age + sex
# Model 2)  + Tumor
# Model 3)  + Tumor + Endothelial
# Model 4)  + Tumor + Endothelial + Epithelial
# Model 5)  + Fib
# Model 6)  + Treg
# Model 7)  + CD4mem
# Model 8)  + CD8mem
# Model 9)  + Bmem
# Model 10) + DC

model_covariates_list <- list(
  c("any_mets", "MLH1", "age", "sex"),  # 1) Base
  c("any_mets", "MLH1", "age", "sex", "Tumor"),   # 2
  c("any_mets", "MLH1", "age", "sex", "Tumor", "Endothelial"),  # 3
  c("any_mets", "MLH1", "age", "sex", "Tumor", "Endothelial", "Epithelial"),  # 4
  c("any_mets", "MLH1", "age", "sex", "Tumor", "Endothelial", "Epithelial", "Fib"),  # 5
  c("any_mets", "MLH1", "age", "sex", "Tumor", "Endothelial", "Epithelial", "Fib", "Treg"),  # 6
  c("any_mets", "MLH1", "age", "sex", "Tumor", "Endothelial", "Epithelial", "Fib", "Treg", "CD4mem"),  # 7
  c("any_mets", "MLH1", "age", "sex", "Tumor", "Endothelial", "Epithelial", "Fib", "Treg", "CD4mem", "CD8mem"),  # 8
  c("any_mets", "MLH1", "age", "sex", "Tumor", "Endothelial", "Epithelial", "Fib", "Treg", "CD4mem", "CD8mem", "Bmem"),  # 9
  c("any_mets", "MLH1", "age", "sex", "Tumor", "Endothelial", "Epithelial", "Fib", "Treg", "CD4mem", "CD8mem", "Bmem", "DC")  # 10
)

##############################################################################
# 3) Helper function to fit limma + run methylGSA for GO & KEGG
##############################################################################
get_GSEA_for_model <- function(
    covariates,
    analysis_data,
    M_value_matrix,
    coef_name = "any_metsTRUE",  # The effect you're testing
    minsize=100,
    maxsize=500
) {
  # 3.1) Build the design matrix from the covariates
  formula_str <- paste("~", paste(covariates, collapse = " + "))
  design <- model.matrix(as.formula(formula_str), data = analysis_data)
  
  # 3.2) Fit model using limma
  fit <- lmFit(M_value_matrix, design)
  fit <- eBayes(fit)
  
  # 3.3) Extract topTable for your coefficient of interest (e.g., any_metsTRUE)
  if (!coef_name %in% colnames(design)) {
    stop(paste("Coefficient", coef_name, "not found in design matrix. Check your factor encoding."))
  }
  
  top_table <- topTable(fit, coef = coef_name, number = Inf, adjust.method = "none")
  
  # 3.4) Create named vector of CpG p-values for methylGSA
  cpg_sites <- rownames(top_table)
  pvals     <- top_table$P.Value
  cpg_pval  <- setNames(pvals, cpg_sites)
  
  # 3.5) Run GSEA for GO
  go_res <- methylglm(
    cpg.pval   = cpg_pval,
    array.type = "EPIC",    # or "450K" if using 450K
    group      = "all",
    GS.type    = "GO", 
    minsize    = minsize,
    maxsize    = maxsize,
    parallel   = FALSE
  )
  
  # 3.6) Run GSEA for KEGG
  kegg_res <- methylglm(
    cpg.pval   = cpg_pval,
    array.type = "EPIC",
    group      = "all",
    GS.type    = "KEGG",
    minsize    = minsize,
    maxsize    = maxsize,
    parallel   = FALSE
  )
  
  # 3.7) Return the top 20 GO and KEGG results
  list(
    GO   = go_res %>% arrange(pvalue) %>% head(40),
    KEGG = kegg_res %>% arrange(pvalue) %>% head(40)
  )
}

##############################################################################
# 4) Run all 10 incremental models in a loop
##############################################################################
all_model_results <- list()

for (i in seq_along(model_covariates_list)) {
  
  covars <- model_covariates_list[[i]]
  cat("\n----------------------------------------------------\n")
  cat("Fitting Model", i, "with covariates:", paste(covars, collapse = ", "), "\n")
  
  # Fit model and get GO/KEGG top 20
  model_res <- get_GSEA_for_model(
    covariates    = covars,
    analysis_data = analysis_data,         # your metadata/covariates data frame
    M_value_matrix = DH_CRC_M_value_filtered, # your M-value matrix
    coef_name     = "any_metsTRUE"         # or whichever coefficient you're testing
  )
  
  # Store in a list
  all_model_results[[i]] <- model_res
}

##############################################################################
# 5) Combine all GO terms (top 20 from each model)
##############################################################################
all_go <- bind_rows(
  lapply(seq_along(all_model_results), function(i) {
    go_df <- all_model_results[[i]]$GO
    go_df$model_index <- i
    go_df
  })
)

# Summarize how often each GO Description appears across models
go_freq <- all_go %>%
  group_by(Description) %>%
  summarize(
    freq = n(), 
    avg_pvalue = mean(pvalue),
    .groups = "drop"
  ) %>%
  arrange(desc(freq))

# Word cloud for GO
wc_go <- go_freq %>%
  select(word = Description, freq)

cat("\n\n**GO Word Cloud**\n")
wordcloud2(
  wc_go,
  size = 1.0,
  color = "random-light",
  backgroundColor = "white"
)

##############################################################################
# 6) Combine all KEGG pathways (top 20 from each model)
##############################################################################
# Combine KEGG results from each model
# Combine KEGG results from each model
all_kegg <- bind_rows(
  lapply(seq_along(all_model_results), function(i) {
    kegg_df <- all_model_results[[i]]$KEGG
    kegg_df$model_index <- i
    kegg_df
  })
)

# Summarize how often each KEGG Description appears across models
kegg_freq <- all_kegg %>%
  group_by(Description) %>%
  summarize(
    freq = n(),                  # how many times it appears in top 20
    avg_pvalue = mean(pvalue),   # optional: average p-value
    .groups = "drop"
  ) %>%
  arrange(desc(freq))

# Build a data frame for the word cloud
wc_kegg <- kegg_freq %>%
  select(word = Description, freq)

cat("\n\n**KEGG Word Cloud**\n")

library(wordcloud2)
wordcloud2(
  wc_kegg,
  size = 1.0,
  color = "random-light",
  backgroundColor = "white"
)

cat("\n\nDone!\n")
```

```{r}
library(ComplexHeatmap)

# 1) Gather top pathways across all models:
all_kegg <- bind_rows(lapply(seq_along(all_model_results), function(i) {
  kegg_df <- all_model_results[[i]]$KEGG
  kegg_df$model_index <- i
  kegg_df
}))

# 2) Create matrix of p-values (or -log10(pvalues)).
#    Suppose we take the union of the top 20 from each model.
unique_paths <- unique(all_kegg$Description)

# Build a data frame with columns for each model
pval_df <- expand.grid(Description = unique_paths, model_index = 1:length(all_model_results)) %>%
  left_join(all_kegg, by = c("Description","model_index")) %>%
  # If the pathway wasn't in that model's top 20, pvalue might be NA => fill with 1 or some large p-value
  mutate(pvalue = ifelse(is.na(pvalue), 1, pvalue),
         negLogP = -log10(pvalue))

# Reshape to wide format
heatmap_mat <- pval_df %>%
  select(Description, model_index, negLogP) %>%
  pivot_wider(names_from = model_index, values_from = negLogP, values_fill = 0)

# Convert to matrix
rn <- heatmap_mat$Description
heatmap_mat <- as.matrix(heatmap_mat[, -1])
rownames(heatmap_mat) <- rn

# 3) Plot heatmap
Heatmap(heatmap_mat,
        name = "-log10(p)",
        cluster_rows = TRUE,  # or FALSE, if you prefer
        cluster_columns = FALSE,
        column_labels = paste("Model", 1:ncol(heatmap_mat)))
```

Here I am generating lists based on the top 20 hyper and hypo methylated GpG's for a given EWAS condition

```{r}
# Step 1: Prepare Combined Data
HiTIMED_result$SampleID <- rownames(HiTIMED_result)
SVA_combined_df$SampleID <- rownames(SVA_combined_df)

# Merge HiTIMED results, targets, and EpiDISH fibroblast data
combined_data <- HiTIMED_result %>%
  left_join(targets, by = "SampleID") %>%
  left_join(cell_type_proportions_df %>% dplyr::select(SampleID, Fib), by = "SampleID") %>%
  left_join(SVA_combined_df, by = 'SampleID')  

# Step 2: Filter out Rectal Samples
combined_data_filtered <- combined_data %>%
  filter(site != "rectum")

# Subset M-value matrix to exclude rectal samples
DH_CRC_M_value_filtered <- DH_CRC_M_value[, combined_data_filtered$SampleID]

# Step 3: Normalize Metadata Columns
combined_data_filtered <- combined_data_filtered %>%
  mutate(
    site = tolower(gsub(" ", "", site)),
    across(c("sex", "any_mets", "MLH1", "Distant_Mets", "ln_only", "node_stage"), as.factor),  
    age = as.numeric(as.character(age))  
  )

# Step 4: Define Relevant Columns for Analysis
relevant_columns <- c("SampleID", "MLH1", "Tumor", "Endothelial", "Epithelial", "Fib", 
                      "CD8mem", "Bmem", "DC", "Treg", "CD4mem", "age", "sex", 
                      "any_mets", "Distant_Mets", "ln_only", "node_stage",
                      "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8")

analysis_data <- combined_data_filtered %>%
  dplyr::select(all_of(relevant_columns)) %>%
  column_to_rownames(var = "SampleID")  

# Check for NA values
if (sum(is.na(analysis_data)) > 0) {
  stop("NA values detected in analysis_data. Please investigate.")
}

# Step 5: Create Design Matrices
adjusted_design <- model.matrix(
  ~ any_mets + MLH1 + Tumor + Endothelial + Epithelial + Fib + Treg + CD4mem + CD8mem + Bmem + DC + age + sex , data = analysis_data)

unadjusted_design <- model.matrix(
  ~ any_mets + MLH1 + age + sex, data = analysis_data)

colnames(adjusted_design) <- make.names(colnames(adjusted_design), unique = TRUE)
colnames(unadjusted_design) <- make.names(colnames(unadjusted_design), unique = TRUE)

# Step 6: Run EWAS for Adjusted and Unadjusted Models
fit_adjusted <- eBayes(lmFit(DH_CRC_M_value_filtered, adjusted_design))
fit_unadjusted <- eBayes(lmFit(DH_CRC_M_value_filtered, unadjusted_design))

# Set new significance threshold
sig_threshold <- 0.01  

# Extract results using the new threshold
adjusted_results <- topTable(fit_adjusted, coef = 'any_metsTRUE', adjust = "none", n = Inf)
unadjusted_results <- topTable(fit_unadjusted, coef = 'any_metsTRUE', adjust = "none", n = Inf)

# Ensure CpG names are consistent between models
common_probes <- intersect(rownames(adjusted_results), rownames(unadjusted_results))
adjusted_results <- adjusted_results[common_probes, ]
unadjusted_results <- unadjusted_results[common_probes, ]

# Get significant CpGs based on the new raw p-value threshold
sig_adjusted <- adjusted_results[adjusted_results$P.Value < sig_threshold, ]
sig_unadjusted <- unadjusted_results[unadjusted_results$P.Value < sig_threshold, ]

# Categorize CpG sites
adjusted_results$category <- "Not Significant"
adjusted_results$category[rownames(adjusted_results) %in% intersect(rownames(sig_adjusted), rownames(sig_unadjusted))] <- "Significant in Both"
adjusted_results$category[rownames(adjusted_results) %in% setdiff(rownames(sig_unadjusted), rownames(sig_adjusted))] <- "No Longer Significant After Adjustment"
adjusted_results$category[rownames(adjusted_results) %in% setdiff(rownames(sig_adjusted), rownames(sig_unadjusted))] <- "Significant After Adjustment"

# Merge with annotation
adjusted_results <- merge(adjusted_results, anno, by.x = "row.names", by.y = "Name")
colnames(adjusted_results)[1] <- "probe"

unadjusted_results <- merge(unadjusted_results, anno, by.x = "row.names", by.y = "Name")
colnames(unadjusted_results)[1] <- "probe"

adjusted_results <- as.data.frame(adjusted_results)
unadjusted_results <- as.data.frame(unadjusted_results)

# Ensure all CpGs have a gene annotation
adjusted_results <- adjusted_results %>%
  mutate(Gene = ifelse(UCSC_RefGene_Name != "", UCSC_RefGene_Name,
                       ifelse(GencodeBasicV12_NAME != "", GencodeBasicV12_NAME,
                              ifelse(GencodeCompV12_NAME != "", GencodeCompV12_NAME, "Unknown"))))

unadjusted_results <- unadjusted_results %>%
  mutate(Gene = ifelse(UCSC_RefGene_Name != "", UCSC_RefGene_Name,
                       ifelse(GencodeBasicV12_NAME != "", GencodeBasicV12_NAME,
                              ifelse(GencodeCompV12_NAME != "", GencodeCompV12_NAME, "Unknown"))))

# Convert adjusted_results and unadjusted_results to data frames
adjusted_results_df <- as.data.frame(adjusted_results)
unadjusted_results_df <- as.data.frame(unadjusted_results)

# Select Top Hypo- and Hyper-Methylated CpGs
top_hyper_adjusted <- adjusted_results %>% 
  filter(logFC > 0) %>% 
  arrange(P.Value) %>% 
  head(20)

top_hypo_adjusted <- adjusted_results %>% 
  filter(logFC < 0) %>% 
  arrange(P.Value) %>% 
  head(20)

top_hyper_unadjusted <- unadjusted_results %>% 
  filter(logFC > 0) %>% 
  arrange(P.Value) %>% 
  head(20)

top_hypo_unadjusted <- unadjusted_results %>% 
  filter(logFC < 0) %>% 
  arrange(P.Value) %>% 
  head(20)

library(knitr)

# Display tables using kable
kable(top_hyper_adjusted[, c("probe", "logFC", "P.Value", "Gene")], caption = "Top 20 Hyper-Methylated CpGs (Adjusted Model)")
kable(top_hypo_adjusted[, c("probe", "logFC", "P.Value", "Gene")], caption = "Top 20 Hypo-Methylated CpGs (Adjusted Model)")
kable(top_hyper_unadjusted[, c("probe", "logFC", "P.Value", "Gene")], caption = "Top 20 Hyper-Methylated CpGs (Unadjusted Model)")
kable(top_hypo_unadjusted[, c("probe", "logFC", "P.Value", "Gene")], caption = "Top 20 Hypo-Methylated CpGs (Unadjusted Model)")
```

Now I want to perform GSEA on the data to investigate it further.

```{r}
# Ensure that probe names and p-values are properly extracted
cpg_sites <- adjusted_results$probe  # Extract CpG probe IDs
p_values <- adjusted_results$P.Value  # Extract corresponding p-values

# Create a named vector suitable for methylGSA
cpg_pval <- setNames(p_values, cpg_sites)

# Quick check of the structure
head(cpg_pval)

# Run methylGSA using methylglm function
go_results_methylGSA <- methylglm(
    cpg.pval = cpg_pval,      # Named vector of CpG p-values
    array.type = "EPIC",      # EPIC array type (or "450K" if using 450K data)
    group = "all",            # Use all annotated CpGs
    GS.type = "GO",           # Gene Ontology (Change to "KEGG" or "Reactome" if needed)
    minsize = 100,            # Minimum size of gene sets to test
    maxsize = 500,            # Maximum size of gene sets to test
    parallel = FALSE          # Run without parallelization (set to TRUE if needed)
)

# View top enriched GO terms
head(go_results_methylGSA)


library(kableExtra)

# Display the top 10 enriched GO terms
go_results_methylGSA %>%
  arrange(pvalue) %>% head(40) %>%
  kable(caption = "Top 10 Enriched GO Terms") %>%
  kable_styling(full_width = FALSE)
```

```{r}
kegg_results_methylGSA <- methylglm(
    cpg.pval = cpg_pval,      
    array.type = "EPIC",      
    group = "all",            
    GS.type = "KEGG",         
    minsize = 100,            
    maxsize = 500,            
    parallel = FALSE          
)

# Display top KEGG pathways
kegg_results_methylGSA %>%
  arrange(pvalue) %>% head(100) %>%
  kable(caption = "Top Enriched KEGG Pathways") %>%
  kable_styling(full_width = FALSE)
```

Looking at contrasts:

```{r}
# Load required packages
library(dplyr)
library(limma)
library(ggplot2)
library(ggrepel)
library(tibble)

# --------------------------
# Step 1: Prepare Combined Data
# --------------------------
HiTIMED_result$SampleID <- rownames(HiTIMED_result)
SVA_combined_df$SampleID <- rownames(SVA_combined_df)

# Merge HiTIMED results, targets, and EpiDISH fibroblast data
combined_data <- HiTIMED_result %>%
  left_join(targets, by = "SampleID") %>%
  left_join(cell_type_proportions_df %>% dplyr::select(SampleID, Fib), by = "SampleID") %>%
  left_join(SVA_combined_df, by = 'SampleID')  

# --------------------------
# Step 2: Filter out Rectal Samples
# --------------------------
combined_data_filtered <- combined_data %>%
  filter(site != "rectum")

# Subset M-value matrix to exclude rectal samples
DH_CRC_M_value_filtered <- DH_CRC_M_value[, combined_data_filtered$SampleID]

# --------------------------
# Step 3: Normalize Metadata Columns
# --------------------------
combined_data_filtered <- combined_data_filtered %>%
  mutate(
    site = tolower(gsub(" ", "", site)),
    across(c("sex", "any_mets", "MLH1", "Distant_Mets", "ln_only", "node_stage"), as.factor),
    age = as.numeric(as.character(age))
  )

# --------------------------
# Step 4: Define Relevant Columns for Analysis
# --------------------------
relevant_columns <- c("SampleID", "MLH1", "Tumor", "Endothelial", "Epithelial", "Fib","Eos", 
                      "CD8mem", "Bmem", "DC", "Treg", "CD4mem", "age", "sex", 
                      "any_mets", "Distant_Mets", "ln_only", "node_stage",
                      "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8","Eos","NK")

analysis_data <- combined_data_filtered %>%
  dplyr::select(all_of(relevant_columns)) %>%
  column_to_rownames(var = "SampleID")  

# Check for NA values
if (sum(is.na(analysis_data)) > 0) {
  stop("NA values detected in analysis_data. Please investigate.")
}

# --------------------------
# Step 5: Create Design Matrix for Post‐Hoc Contrasts
# --------------------------
# Here we use only the relevant variables to capture the metastasis effect (any_mets),
# MLH1 status, and their interaction.
design <- model.matrix(~ any_mets * MLH1 + MLH1 + age + sex + CD8mem + Bmem + Treg + Tumor + Endothelial + Epithelial + Fib + CD4mem + DC + Bmem + Eos + NK, data = analysis_data)
# Standardize column names (e.g., interaction term may become "any_metsTRUE.MLH11")
colnames(design) <- make.names(colnames(design), unique = TRUE)
print("Design matrix columns:")
print(colnames(design))
# The expected columns are:
# "(Intercept)", "any_metsTRUE", "MLH11", "any_metsTRUE.MLH11"

# --------------------------
# Step 6: Fit Linear Model and Define Contrasts
# --------------------------
# Fit the linear model on the M-value matrix
fit <- lmFit(DH_CRC_M_value_filtered, design)

# Define contrasts to estimate the effect of metastasis (any_mets) within each MLH1 stratum:
# - For MLH1 = 0: the effect is given by the coefficient "any_metsTRUE"
# - For MLH1 = 1: the effect is the sum of "any_metsTRUE" and the interaction "any_metsTRUE.MLH11"
contrast.matrix <- makeContrasts(
  mets_effect_MLH1_0 = any_metsTRUE,
  mets_effect_MLH1_1 = any_metsTRUE + any_metsTRUE.MLH11,
  levels = design
)
print("Contrast matrix:")
print(contrast.matrix)

# Apply contrasts and compute moderated statistics
fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)

# --------------------------
# Step 7: Extract Contrast Results and Summarize
# --------------------------
# Set significance threshold
sig_threshold <- 0.01  

# Extract results for each contrast
results_MLH1_0 <- topTable(fit2, coef = "mets_effect_MLH1_0", adjust.method = "none", number = Inf)
results_MLH1_1 <- topTable(fit2, coef = "mets_effect_MLH1_1", adjust.method = "none", number = Inf)

# Print number of significant CpGs for each contrast
cat("Number of significant CpGs in MLH1=0 group (p < ", sig_threshold, "): ", 
    sum(results_MLH1_0$P.Value < sig_threshold), "\n")
cat("Number of significant CpGs in MLH1=1 group (p < ", sig_threshold, "): ", 
    sum(results_MLH1_1$P.Value < sig_threshold), "\n")

# Add a column to denote the contrast group and the probe names
results_MLH1_0$Contrast <- "MLH1=0"
results_MLH1_1$Contrast <- "MLH1=1"
results_MLH1_0$probe <- rownames(results_MLH1_0)
results_MLH1_1$probe <- rownames(results_MLH1_1)

# Combine the two sets of results for visualization
combined_results <- rbind(results_MLH1_0, results_MLH1_1)
combined_results$logPval <- -log10(combined_results$P.Value)

# --------------------------
# Step 8: Create Volcano Plot for Each Contrast
# --------------------------
volcano_plot <- ggplot(combined_results, aes(x = logFC, y = logPval, color = Contrast)) +
  geom_point(alpha = 0.5) +
  facet_wrap(~ Contrast) +
  theme_minimal() +
  labs(title = "Volcano Plot: Metastasis Effect by MLH1 Status (P < 0.01)",
       x = "Log Fold Change", 
       y = "-log10(p-value)") +
  scale_color_manual(values = c("MLH1=0" = "blue", "MLH1=1" = "red"))

# Label top significant CpGs (using a more stringent threshold for labeling)
volcano_plot <- volcano_plot + 
  geom_text_repel(data = subset(combined_results, P.Value < 0.001 & abs(logFC) > 1), 
                  aes(label = probe),
                  size = 3, 
                  max.overlaps = 10)

print(volcano_plot)
```

```{r}
library(dplyr)
library(ggplot2)
library(ggrepel)

# Define thresholds
sig_threshold <- 0.01
logFC_threshold <- 1

# Assume combined_results already contains the following columns:
# - logFC: Log Fold Change for each CpG site
# - P.Value: Raw p-values for each site
# - Contrast: A factor indicating the contrast (e.g., "MLH1=0" or "MLH1=1")
# - probe: CpG site names

# Create a significance category column based on thresholds
combined_results <- combined_results %>%
  mutate(Significance = case_when(
    P.Value < sig_threshold & abs(logFC) >= logFC_threshold ~ "Significant",
    TRUE ~ "Not Significant"
  ))

# Create volcano plot with cutoff lines and colored points
volcano_plot <- ggplot(combined_results, aes(x = logFC, y = -log10(P.Value), color = Significance)) +
  geom_point(alpha = 0.5) +
  facet_wrap(~ Contrast) +
  geom_hline(yintercept = -log10(sig_threshold), linetype = "dashed", color = "black") +
  geom_vline(xintercept = c(-logFC_threshold, logFC_threshold), linetype = "dashed", color = "black") +
  scale_color_manual(values = c("Significant" = "red", "Not Significant" = "gray")) +
  labs(title = "Volcano Plot: Metastasis Effect by MLH1 Status",
       x = "Log Fold Change",
       y = "-log10(p-value)") +
  theme_minimal()

# Optionally, add labels for the top significant CpGs
volcano_plot <- volcano_plot + 
  geom_text_repel(
    data = subset(combined_results, Significance == "Significant" & P.Value < 0.001),
    aes(label = probe),
    size = 3, 
    max.overlaps = 10
  )

print(volcano_plot)
```

```{r}
# --------------------------
# Assuming I've already run the contrast analysis and have:
# results_MLH1_0 and results_MLH1_1 as produced in your contrast workflow.
# --------------------------

# For the MLH1 = 0 contrast:

# Extract CpG probe IDs and p-values
cpg_sites_MLH1_0 <- results_MLH1_0$probe     # Probe IDs
p_values_MLH1_0 <- results_MLH1_0$P.Value     # Corresponding p-values

# Create a named vector suitable for methylGSA
cpg_pval_MLH1_0 <- setNames(p_values_MLH1_0, cpg_sites_MLH1_0)
head(cpg_pval_MLH1_0)  # Quick check

# Run methylGSA using methylglm for the MLH1 = 0 contrast
go_results_MLH1_0 <- methylglm(
    cpg.pval = cpg_pval_MLH1_0,   # Named vector of CpG p-values for MLH1=0
    array.type = "EPIC",          # Array type ("EPIC" or "450K")
    group = "all",                # Use all annotated CpGs
    GS.type = "GO",               # Gene set type (change to "KEGG" or "Reactome" if needed)
    minsize = 100,                # Minimum size of gene sets to test
    maxsize = 500,                # Maximum size of gene sets to test
    parallel = FALSE              # Parallel processing (set to TRUE if desired)
)

# View the top enriched GO terms for MLH1=0 contrast
head(go_results_MLH1_0,n=20)


# For the MLH1 = 1 contrast:

# Extract CpG probe IDs and p-values
cpg_sites_MLH1_1 <- results_MLH1_1$probe
p_values_MLH1_1 <- results_MLH1_1$P.Value

# Create a named vector suitable for methylGSA
cpg_pval_MLH1_1 <- setNames(p_values_MLH1_1, cpg_sites_MLH1_1)
head(cpg_pval_MLH1_1)  # Quick check

# Run methylGSA using methylglm for the MLH1 = 1 contrast
go_results_MLH1_1 <- methylglm(
    cpg.pval = cpg_pval_MLH1_1,   # Named vector of CpG p-values for MLH1=1
    array.type = "EPIC",          # Array type ("EPIC" or "450K")
    group = "all",                # Use all annotated CpGs
    GS.type = "GO",               # Gene set type (or "KEGG", "Reactome", etc.)
    minsize = 100,                # Minimum size of gene sets to test
    maxsize = 500,                # Maximum size of gene sets to test
    parallel = FALSE              # Parallel processing (set to TRUE if desired)
)

# View the top enriched GO terms for MLH1=1 contrast
head(go_results_MLH1_1)

library(dplyr)
library(knitr)
library(kableExtra)

# Arrange the GO results by p-value and select the top 20 rows.
go_results_table <- go_results_MLH1_0 %>%
  arrange(pvalue) %>%
  head(20)

# Print the table with a caption.
go_results_table %>%
  kable(caption = "Top Enriched GO Terms for MLH1 = 0") %>%
  kable_styling(full_width = FALSE)


```

```{r}
# --------------------------
# For the MLH1 = 0 contrast:
# --------------------------
# Extract CpG probe IDs and corresponding p-values from the MLH1=0 results
cpg_sites_MLH1_0 <- results_MLH1_0$probe     # Adjust if your column name differs
p_values_MLH1_0  <- results_MLH1_0$P.Value

# Create a named vector of p-values
cpg_pval_MLH1_0 <- setNames(p_values_MLH1_0, cpg_sites_MLH1_0)
head(cpg_pval_MLH1_0)  # Quick check

# Run methylGSA for KEGG enrichment using methylglm for MLH1=0
kegg_results_MLH1_0 <- methylglm(
    cpg.pval  = cpg_pval_MLH1_0,      
    array.type = "EPIC",      
    group      = "all",            
    GS.type    = "KEGG",         
    minsize    = 100,            
    maxsize    = 500,            
    parallel   = FALSE          
)

# Display top 20 enriched KEGG pathways for MLH1=0
kegg_results_MLH1_0 %>%
  arrange(pvalue) %>% head(20) %>%
  kable(caption = "Top Enriched KEGG Pathways for MLH1 = 0") %>%
  kable_styling(full_width = FALSE)

# --------------------------
# For the MLH1 = 1 contrast:
# --------------------------
# Extract CpG probe IDs and corresponding p-values from the MLH1=1 results
cpg_sites_MLH1_1 <- results_MLH1_1$probe
p_values_MLH1_1  <- results_MLH1_1$P.Value

# Create a named vector of p-values
cpg_pval_MLH1_1 <- setNames(p_values_MLH1_1, cpg_sites_MLH1_1)
head(cpg_pval_MLH1_1)  # Quick check

# Run methylGSA for KEGG enrichment using methylglm for MLH1=1
kegg_results_MLH1_1 <- methylglm(
    cpg.pval  = cpg_pval_MLH1_1,      
    array.type = "EPIC",      
    group      = "all",            
    GS.type    = "KEGG",         
    minsize    = 100,            
    maxsize    = 500,            
    parallel   = FALSE          
)

# Display top 20 enriched KEGG pathways for MLH1=1
kegg_results_MLH1_1 %>%
  arrange(pvalue) %>% head(20) %>%
  kable(caption = "Top Enriched KEGG Pathways for MLH1 = 1") %>%
  kable_styling(full_width = FALSE)
```

# manhattan plot

# 

# 

# 

# 

# 

Trying to run bumpbunter

```{r}
### Load required packages
library(minfi)
library(GenomicRanges)
library(bumphunter)
library(dplyr)
# Load the EPIC annotation package:
library(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)

### STEP 1. Prepare Genomic Annotation and Create GenomicRatioSet

# (Optional) You can check the annotation data:
data("IlluminaHumanMethylationEPICanno.ilm10b4.hg19")
# Note: 'anno' here is obtained as:
anno <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)

# Identify probes common to your M-value matrix and the annotation.
# (This step can help ensure that the rownames of DH_CRC_M_value_filtered match those in the EPIC annotation.)
common_probes <- intersect(rownames(DH_CRC_M_value_filtered), anno$Name)
Mvals_sub <- DH_CRC_M_value_filtered[common_probes, ]

# Instead of subsetting the annotation manually, we let makeGenomicRatioSetFromMatrix load the annotation.
# Create the GenomicRatioSet using the EPIC array and annotation for hg19.
grset <- makeGenomicRatioSetFromMatrix(
  Mvals_sub,
  pData = combined_data_filtered,
  array = "IlluminaHumanMethylationEPIC",
  annotation = "ilm10b4.hg19"
)

### STEP 2. (Optional) Remove Sex-Chromosome Probes
# If you already removed sex-linked probes during QC, this may be unnecessary.
# To be extra sure, remove probes on chrX and chrY:
grset <- grset[!seqnames(grset) %in% c("chrX", "chrY")]

### STEP 3. Stratify by MLH1 Status and Create Design Matrices for the Metastasis Effect

# Ensure that MLH1 and any_mets are factors in the pData.
pData(grset)$MLH1 <- as.factor(pData(grset)$MLH1)
pData(grset)$any_mets <- as.factor(pData(grset)$any_mets)

# Split the GenomicRatioSet by MLH1 status.
grset_MLH1_0 <- grset[, pData(grset)$MLH1 == "0"]
grset_MLH1_1 <- grset[, pData(grset)$MLH1 == "1"]

# Create a design matrix for the effect of metastasis (any_mets) in each stratum.
design_MLH1_0 <- model.matrix(~ any_mets, data = pData(grset_MLH1_0))
design_MLH1_1 <- model.matrix(~ any_mets, data = pData(grset_MLH1_1))

### STEP 4. Run bumphunter in Each Stratum

# Set a cutoff for the minimal difference (in M-values) to consider a bump.
cutoff <- 0.2  # Adjust this value based on your data's variability.

# Set a random seed for reproducibility.
set.seed(123)
library(doParallel)
library(rngtools)
registerDoParallel(cores = 9) 
# Run bumphunter for the MLH1 = 0 group.
bumps_MLH1_0 <- bumphunter(grset_MLH1_0, design = design_MLH1_0,
                           cutoff = cutoff, B = 5, parallel = TRUE,verbose = TRUE)

# Run bumphunter for the MLH1 = 1 group.
set.seed(123)
bumps_MLH1_1 <- bumphunter(grset_MLH1_1, design = design_MLH1_1,
                           cutoff = cutoff, B = 5, parallel = TRUE,verbose = TRUE)

### STEP 5. Examine the bumphunter Results

# Print the number of DMRs found in each stratum.
cat("Number of DMRs found in MLH1 = 0 group:", bumps_MLH1_0$found, "\n")
cat("Number of DMRs found in MLH1 = 1 group:", bumps_MLH1_1$found, "\n")

# View summary tables (e.g., top 6 regions) for each group.
head(bumps_MLH1_0$table)
head(bumps_MLH1_1$table)

# Filter for significant DMRs using the family-wise error rate (FWER).
sig_DMRs_MLH1_0 <- bumps_MLH1_0$table[bumps_MLH1_0$table$fwer < 0.05, ]
sig_DMRs_MLH1_1 <- bumps_MLH1_1$table[bumps_MLH1_1$table$fwer < 0.05, ]

cat("Significant DMRs (FWER < 0.05) in MLH1 = 0 group:", nrow(sig_DMRs_MLH1_0), "\n")
cat("Significant DMRs (FWER < 0.05) in MLH1 = 1 group:", nrow(sig_DMRs_MLH1_1), "\n")
```

```{r}
# Minimal test with a subset of 1000 probes
test_probes <- rownames(DH_CRC_M_value_filtered)[1:1000]
test_Mvals <- DH_CRC_M_value_filtered[test_probes, ]
test_anno <- anno[match(test_probes, anno$Name), ]

library(GenomicRanges)
gr <- GRanges(seqnames = test_anno$chr,
              ranges = IRanges(start = test_anno$pos, width = 1),
              strand = test_anno$strand,
              names = test_anno$Name)

# Create GenomicRatioSet with a subset
grset_test <- makeGenomicRatioSetFromMatrix(
  test_Mvals,
  pData = combined_data_filtered,
  array = "IlluminaHumanMethylationEPIC",
  annotation = "ilm10b4.hg19"
)

print(grset_test)
```

VIF work:

```{r}
library(car)       # for vif()
library(dplyr)

relevant_columns <- c("SampleID", "MLH1", "Tumor", "Endothelial", "Epithelial", "Fib", 
                      "CD8mem", "Bmem", "DC", "Treg", "CD4mem", "age", "sex", 
                      "any_mets", "Distant_Mets", "ln_only", "node_stage",
                      "PC1", "PC2", "PC3", "PC4", "PC5","Eos", "PC6", "PC7", "PC8","Eos","NK")

analysis_data <- combined_data_filtered %>%
  dplyr::select(all_of(relevant_columns)) %>%
  column_to_rownames(var = "SampleID")

# Define your model formula as a character string.
# (Note: Bmem appears twice. If that's not intended, remove one instance.)
model_formula <- "M_val ~ any_mets * MLH1 + MLH1 + age + sex + CD8mem + Bmem + Treg + Tumor + Endothelial + Epithelial + Fib + CD4mem + DC + Bmem + Eos + NK"

# For computational efficiency, select a random subset of CpGs (e.g., 1000 probes)
set.seed(123)
selected_cpgs <- sample(rownames(DH_CRC_M_value_filtered), 20000)

# Subset the M-value matrix to these probes.
tmp_Mvals <- DH_CRC_M_value_filtered[selected_cpgs, ]
# Ensure the columns (samples) are in the same order as in analysis_data.
tmp_Mvals <- tmp_Mvals[, rownames(analysis_data)]

# Extract the covariate data from your analysis_data.
# Make sure these column names exactly match those in your model formula.
covariate_vars <- c("any_mets", "MLH1", "age", "sex", "CD8mem", "Bmem", "Treg", 
                    "Tumor", "Endothelial", "Epithelial", "Fib", "CD4mem", "DC","Eos","NK")
covariates <- analysis_data[, covariate_vars]

# Initialize a list to store the VIF values for each CpG.
vif_list <- vector("list", length = nrow(tmp_Mvals))

# Loop through each CpG
for(i in 1:nrow(tmp_Mvals)) {
  # Extract the methylation (M-value) for this CpG across samples.
  M_val <- as.numeric(tmp_Mvals[i, ])
  
  # Create a data frame combining the covariates with the CpG M-value.
  df_model <- covariates %>% 
    mutate(M_val = M_val)
  
  # Fit the linear model using the specified formula.
  # Convert the character formula to an actual formula.
  mod <- lm(as.formula(model_formula), data = df_model)
  
  # Compute the VIF values for the model.
  vif_vals <- car::vif(mod)
  
  # Store the VIF values.
  vif_list[[i]] <- vif_vals
}

# Combine the VIF results into a matrix (each row = one CpG, each column = one coefficient)
vif_matrix <- do.call(rbind, vif_list)

# Calculate the average VIF for each coefficient across all tested CpGs.
avg_VIFs <- colMeans(vif_matrix)

# Print the average VIFs.
print(avg_VIFs)

# Create a data frame from the avg_VIFs vector
vif_table <- data.frame(
  Variable = names(avg_VIFs),
  Avg_VIF = avg_VIFs,
  row.names = NULL
)

# Print the table using knitr::kable for a nicer display
library(knitr)
kable(vif_table, caption = "Average VIF Values for Model Covariates")
```

```{r}
library(ggplot2)
library(knitr)

# Create a data frame from the avg_VIFs vector
vif_table <- data.frame(
  Variable = names(avg_VIFs),
  Avg_VIF = avg_VIFs,
  row.names = NULL
)

# Optionally, print the table nicely:
kable(vif_table, caption = "Average VIF Values for Model Covariates")

# Create a horizontal bar plot
ggplot(vif_table, aes(x = reorder(Variable, Avg_VIF), y = Avg_VIF)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  geom_text(aes(label = round(Avg_VIF, 2)), hjust = -0.1, size = 4) +
  coord_flip() +
  theme_minimal() +
  labs(title = "Average VIF by Covariate",
       x = "Covariate",
       y = "Average VIF") +
  ylim(0, max(vif_table$Avg_VIF) * 1.1)
```

```{r}
# Load necessary packages
library(dplyr)
library(pheatmap)

# Define the categorical variables you wish to examine.
# Adjust these names to match the columns in your data.
categorical_vars <- c("MLH1", "any_mets","age", "sex", "CD8mem", "Bmem", "Treg", "Tumor", "Endothelial", "Epithelial", "Fib", "CD4mem", "DC","Eos","node_stage","NK")

# Ensure these variables are factors in your dataset.
analysis_data[categorical_vars] <- lapply(analysis_data[categorical_vars], factor)

# (Optional) Check the structure to ensure they are factors.
str(analysis_data[categorical_vars])

# Initialize a p-value matrix with appropriate dimensions and names.
pval_matrix <- matrix(NA,
                      nrow = length(categorical_vars),
                      ncol = length(categorical_vars),
                      dimnames = list(categorical_vars, categorical_vars))

# Loop over each pair of categorical variables.
for (i in seq_along(categorical_vars)) {
  for (j in seq_along(categorical_vars)) {
    if (i != j) {
      # Create a contingency table between variable i and variable j.
      contingency_table <- table(analysis_data[[categorical_vars[i]]],
                                 analysis_data[[categorical_vars[j]]])
      
      # Only perform the test if the table has at least 2 rows and 2 columns.
      if (nrow(contingency_table) > 1 && ncol(contingency_table) > 1) {
        # Perform Fisher's Exact Test.
        # Using simulate.p.value = TRUE with a high number of replicates.
        fisher_test <- fisher.test(contingency_table, simulate.p.value = TRUE, B = 1e5)
        
        # Store the p-value in the matrix.
        pval_matrix[i, j] <- fisher_test$p.value
      }
    }
  }
}

# Replace any NA values (which might occur if a test wasn't run) with 1,
# so that when we transform to -log10(p) they become 0.
pval_matrix[is.na(pval_matrix)] <- 1

# Optionally, print the p-value matrix.
print(pval_matrix)

# Create a heatmap of the -log10 transformed p-values.
pheatmap(-log10(pval_matrix), 
         display_numbers = TRUE, 
         number_format = "%.2f",
         main = "Heatmap of Fisher's Exact Test (-log10 p-values)",
         cluster_rows = FALSE, 
         cluster_cols = FALSE)


library(corrplot)

# For the correlation plot, we'll focus on the numeric variables in analysis_data.
# Identify which columns in analysis_data are numeric.
numeric_vars <- sapply(analysis_data, is.numeric)

# Compute the correlation matrix using pairwise complete observations.
cor_matrix <- cor(analysis_data[, numeric_vars], use = "pairwise.complete.obs")

# Print the correlation matrix to inspect it
print(cor_matrix)

# Create a correlation plot.
# The method "color" produces a colored matrix, and we display only the upper triangle.
corrplot(cor_matrix, method = "color", type = "upper",
         tl.col = "black", tl.srt = 45, addCoef.col = "black",
         title = "Correlation Matrix of Numeric Predictors", mar=c(0,0,1,0))
```

```{r}
# Load necessary packages
library(dplyr)
library(pheatmap)
library(tidyr)

# --------------------------
# Step 1: Prepare the Data
# --------------------------
# Define the categorical variables you want to compare (excluding "any_mets")
cat_vars <- c("MLH1", "any_mets","age", "sex", "CD8mem", "Bmem", "Treg", "Tumor", "Endothelial", "Epithelial", "Fib", "CD4mem", "DC","Eos","node_stage","NK")

# Ensure that these variables are factors
analysis_data[cat_vars] <- lapply(analysis_data[cat_vars], factor)

# Ensure that the grouping variable (any_mets) is a factor.
# It should have exactly two levels (e.g., "control" and "metastasis" or "0" and "1")
analysis_data$any_mets <- factor(analysis_data$any_mets)

# (Optional) Check the levels of any_mets
print("Levels of any_mets:")
print(levels(analysis_data$any_mets))

# --------------------------
# Step 2: Run Fisher’s Exact Test for Each Variable
# --------------------------
# Initialize a data frame to store the results.
fisher_results <- data.frame(Variable = character(),
                             p_value = numeric(),
                             stringsAsFactors = FALSE)

# Loop over each categorical variable.
for (var in cat_vars) {
  # Build the contingency table comparing the current variable vs. any_mets.
  contingency_table <- table(analysis_data[[var]], analysis_data$any_mets)
  
  # Check if the table has at least 2 rows and 2 columns.
  if (nrow(contingency_table) > 1 && ncol(contingency_table) > 1) {
    # Perform Fisher's Exact Test with simulation
    test_result <- fisher.test(contingency_table, simulate.p.value = TRUE, B = 1e5)
    p_val <- test_result$p.value
  } else {
    p_val <- NA  # If not enough levels, record NA.
  }
  
  # Append the result to the results data frame.
  fisher_results <- rbind(fisher_results,
                          data.frame(Variable = var,
                                     p_value = p_val,
                                     stringsAsFactors = FALSE))
}

# Replace any NA p-values with 1 (so that -log10(1)=0)
fisher_results$p_value[is.na(fisher_results$p_value)] <- 1

# Print the Fisher test results table.
print("Fisher's Exact Test Results:")
print(fisher_results)

# --------------------------
# Step 3: Create a Heatmap of -log10(p-values)
# --------------------------
# Convert the results to a matrix.
# We use the p_value column, with variables as rownames.
pval_matrix <- as.matrix(fisher_results$p_value)
rownames(pval_matrix) <- fisher_results$Variable
colnames(pval_matrix) <- "p_value"

# Plot the heatmap with pheatmap.
pheatmap(-log10(pval_matrix), 
         display_numbers = TRUE, 
         number_format = "%.2f",
         main = "Fisher's Exact Test Mets vs Non-Mets (-log10 p-values)",
         cluster_rows = FALSE, 
         cluster_cols = FALSE)
```

```{r}
# Load necessary packages
library(limma)
library(ggplot2)
library(ggrepel)
library(patchwork)

relevant_columns <- c("SampleID", "MLH1", "Tumor", "Endothelial", "Epithelial", "Fib","Eos", 
                      "CD8mem", "Bmem", "DC", "Treg", "CD4mem", "age", "sex", 
                      "any_mets", "Distant_Mets", "ln_only", "node_stage",
                      "PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8","Eos","NK")

analysis_data <- combined_data_filtered %>%
  dplyr::select(all_of(relevant_columns)) %>%
  column_to_rownames(var = "SampleID") 


# Define cutoff values
p_cutoff <- 0.01
fc_cutoff <- 1

### Model 1: Age, Sex & MLH1 Adjustment ###
design1 <- model.matrix(~ any_mets + age + sex + MLH1, data = analysis_data)
fit1 <- lmFit(DH_CRC_M_value_filtered, design1)
fit1 <- eBayes(fit1)
results1 <- topTable(fit1, coef = "any_metsTRUE", adjust.method = "none", n = Inf)
results1$logPval <- -log10(results1$P.Value)

# Create grouping variable based on significance and direction
results1$group <- "Not Sig"
results1$group[results1$P.Value < p_cutoff & results1$logFC >= fc_cutoff] <- "Hyper"
results1$group[results1$P.Value < p_cutoff & results1$logFC <= -fc_cutoff] <- "Hypo"
results1$group <- factor(results1$group, levels = c("Not Sig", "Hypo", "Hyper"))

volcano1 <- ggplot(results1, aes(x = logFC, y = logPval, color = group)) +
  geom_point(alpha = 0.5) +
  scale_color_manual(values = c("Not Sig" = "grey", "Hyper" = "red", "Hypo" = "blue")) +
  geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed", color = "black") +
  geom_vline(xintercept = c(-fc_cutoff, fc_cutoff), linetype = "dashed", color = "black") +
  theme_minimal() +
  labs(title = "Model 1: Age, Sex & MLH1",
       x = "Log Fold Change",
       y = "-log10(p-value)",
       color = "Methylation Status")

### Model 2: Age, Sex, MLH1 & Tumor Adjustment ###
design2 <- model.matrix(~ any_mets + age + sex + MLH1 + Tumor, data = analysis_data)
fit2 <- lmFit(DH_CRC_M_value_filtered, design2)
fit2 <- eBayes(fit2)
results2 <- topTable(fit2, coef = "any_metsTRUE", adjust.method = "none", n = Inf)
results2$logPval <- -log10(results2$P.Value)

results2$group <- "Not Sig"
results2$group[results2$P.Value < p_cutoff & results2$logFC >= fc_cutoff] <- "Hyper"
results2$group[results2$P.Value < p_cutoff & results2$logFC <= -fc_cutoff] <- "Hypo"
results2$group <- factor(results2$group, levels = c("Not Sig", "Hypo", "Hyper"))

volcano2 <- ggplot(results2, aes(x = logFC, y = logPval, color = group)) +
  geom_point(alpha = 0.5) +
  scale_color_manual(values = c("Not Sig" = "grey", "Hyper" = "red", "Hypo" = "blue")) +
  geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed", color = "black") +
  geom_vline(xintercept = c(-fc_cutoff, fc_cutoff), linetype = "dashed", color = "black") +
  theme_minimal() +
  labs(title = "Model 2: Age, Sex, MLH1 & Tumor",
       x = "Log Fold Change",
       y = "-log10(p-value)",
       color = "Methylation Status")

### Model 3: Full Adjustment with Cell Types ###
design3 <- model.matrix(~ any_mets + MLH1 + age + sex + CD8mem + Bmem + Treg + Tumor +
                          Endothelial + Epithelial + Fib + CD4mem + DC + Eos + NK, data = analysis_data)
fit3 <- lmFit(DH_CRC_M_value_filtered, design3)
fit3 <- eBayes(fit3)
results3 <- topTable(fit3, coef = "any_metsTRUE", adjust.method = "none", n = Inf)
results3$logPval <- -log10(results3$P.Value)

results3$group <- "Not Sig"
results3$group[results3$P.Value < p_cutoff & results3$logFC >= fc_cutoff] <- "Hyper"
results3$group[results3$P.Value < p_cutoff & results3$logFC <= -fc_cutoff] <- "Hypo"
results3$group <- factor(results3$group, levels = c("Not Sig", "Hypo", "Hyper"))

volcano3 <- ggplot(results3, aes(x = logFC, y = logPval, color = group)) +
  geom_point(alpha = 0.5) +
  scale_color_manual(values = c("Not Sig" = "grey", "Hyper" = "red", "Hypo" = "blue")) +
  geom_hline(yintercept = -log10(p_cutoff), linetype = "dashed", color = "black") +
  geom_vline(xintercept = c(-fc_cutoff, fc_cutoff), linetype = "dashed", color = "black") +
  theme_minimal() +
  labs(title = "Model 3: Full Adjustment (Cell Types)",
       x = "Log Fold Change",
       y = "-log10(p-value)",
       color = "Methylation Status")

### Combine the Three Volcano Plots Side-by-Side ###
combined_volcano <- volcano1 + volcano2 + volcano3 + plot_layout(ncol = 3)
print(combined_volcano)

### Save the Combined Plot as a PDF ###
ggsave("combined_volcano.pdf", combined_volcano, width = 16, height = 6, units = "in")
```

```{r}
library(EnhancedVolcano)
library(patchwork)

# Define cutoffs (adjust as needed)
p_cutoff <- 0.01
fc_cutoff <- 1.0

# Enhanced Volcano for Model 1 (Age & Sex Adjustment)
volcano1 <- EnhancedVolcano(results1,
                            lab = rownames(results1),
                            x = 'logFC',
                            y = 'P.Value',
                            xlab = "Log Fold Change",
                            ylab = "-log10(p-value)",
                            title = "Age & Sex Adjustment",
                            pCutoff = p_cutoff,
                            FCcutoff = fc_cutoff,
                            pointSize = 2.0,
                            labSize = 3.0,
                            colAlpha = 1,
                            legendPosition = "right")

# Enhanced Volcano for Model 2 (Age, Sex & Tumor Adjustment)
volcano2 <- EnhancedVolcano(results2,
                            lab = rownames(results2),
                            x = 'logFC',
                            y = 'P.Value',
                            xlab = "Log Fold Change",
                            ylab = "-log10(p-value)",
                            title = "Age, Sex & Tumor Adjustment",
                            pCutoff = p_cutoff,
                            FCcutoff = fc_cutoff,
                            pointSize = 2.0,
                            labSize = 3.0,
                            colAlpha = 1,
                            legendPosition = "right")

# Enhanced Volcano for Model 3 (Full Adjustment with Cell Types)
volcano3 <- EnhancedVolcano(results3,
                            lab = rownames(results3),
                            x = 'logFC',
                            y = 'P.Value',
                            xlab = "Log Fold Change",
                            ylab = "-log10(p-value)",
                            title = "Full Adjustment (Cell Types)",
                            pCutoff = p_cutoff,
                            FCcutoff = fc_cutoff,
                            pointSize = 2.0,
                            labSize = 3.0,
                            colAlpha = 1,
                            legendPosition = "right")

# Combine the three volcano plots side-by-side using patchwork
combined_volcano <- volcano1 + volcano2 + volcano3 + plot_layout(ncol = 3)
print(combined_volcano)
ggsave("combined_volcano.png", combined_volcano, width = 16, height = 10, units = "in")
```

```{r}
# Load required package
library(ggcorrplot)

# Define the cell type variables you want to examine.
# Adjust these names as needed to reflect your cell-type proportions.
cell_type_vars <- c("Tumor", "Endothelial", "Epithelial", "Fib", "Eos", 
                    "CD8mem", "Bmem", "DC", "Treg", "CD4mem", "NK")

# Subset analysis_data to include only the cell type columns.
# (Ensure these columns are numeric; if they are proportions, they should be.)
cell_type_data <- analysis_data[, cell_type_vars]

# Compute the correlation matrix (using pairwise complete observations).
cor_matrix <- cor(cell_type_data, use = "pairwise.complete.obs")

# Visualize the correlation matrix as a heatmap.
ggcorrplot(cor_matrix, 
           hc.order = TRUE, 
           type = "lower", 
           lab = TRUE, 
           lab_size = 3,
           title = "Correlation Matrix for Cell Types")
```

Look at contingency tables T-tests

```{r}
# Load necessary packages
library(dplyr)
library(tidyr)
library(knitr)
library(kableExtra)

# --------------------------
# Step 2: Filter out Rectal Samples
# --------------------------
combined_data_filtered <- combined_data 
# --------------------------
# Step 3: Normalize Metadata Columns
# --------------------------
combined_data_filtered <- combined_data_filtered %>%
  mutate(
    site = tolower(gsub(" ", "", site)),
    across(c("sex", "any_mets", "MLH1", "Distant_Mets", "ln_only", "node_stage"), as.factor),
    age = as.numeric(as.character(age))
  )

# Define the cell-type variables of interest.
cell_type_vars <- c("Tumor", "Endothelial", "Epithelial", "Fib", "Eos", 
                    "CD8mem", "Bmem", "Treg", "CD4mem", "DC", "NK")

# Rename the outcome levels for clarity: assume any_mets is currently "FALSE" and "TRUE"
combined_data_filtered$any_mets <- factor(combined_data_filtered$any_mets, 
                                          levels = c("FALSE", "TRUE"),
                                          labels = c("No Metastasis", "Metastasis"))

# --------------------------
# Step 1: Compute Summary Statistics by Metastasis Status
# --------------------------
summary_table <- combined_data_filtered %>%
  group_by(any_mets) %>%
  summarise(across(all_of(cell_type_vars),
                   list(mean = ~mean(.x, na.rm = TRUE),
                        sd   = ~sd(.x, na.rm = TRUE),
                        median = ~median(.x, na.rm = TRUE)),
                   .names = "{.col}_{.fn}"))

# Pivot to long format
summary_long <- summary_table %>%
  pivot_longer(-any_mets, names_to = "temp", values_to = "Value") %>%
  separate(temp, into = c("CellType", "Statistic"), sep = "_")

# Pivot wider so that for each cell type we have one row with separate columns for each metastasis status.
summary_wide <- summary_long %>%
  pivot_wider(names_from = any_mets, values_from = Value)

# Now pivot so that each cell type is one row with separate columns for each statistic.
final_summary <- summary_wide %>%
  pivot_wider(names_from = Statistic, values_from = c(`No Metastasis`, Metastasis))

# Rename columns for clarity.
final_summary <- final_summary %>%
  rename(`Cell Type` = CellType,
         `Mean (No Metastasis)` = `No Metastasis_mean`,
         `SD (No Metastasis)` = `No Metastasis_sd`,
         `Median (No Metastasis)` = `No Metastasis_median`,
         `Mean (Metastasis)` = Metastasis_mean,
         `SD (Metastasis)` = Metastasis_sd,
         `Median (Metastasis)` = Metastasis_median)

# --------------------------
# Step 2: Perform t-tests for each cell type comparing metastasis groups
# --------------------------
pval_list <- lapply(cell_type_vars, function(var) {
  test <- t.test(combined_data_filtered[[var]] ~ combined_data_filtered$any_mets)
  data.frame(`Cell Type` = var, `p-value` = test$p.value)
})
pval_table <- do.call(rbind, pval_list)

# --------------------------
# Step 3: Merge the p-value results with the summary statistics
# --------------------------
# Rename the join column in pval_table to match final_summary
pval_table <- pval_table %>% 
  rename(`Cell Type` = Cell.Type)

# Merge the p-value results with the summary statistics
final_table <- final_summary %>%
  left_join(pval_table, by = "Cell Type") %>%
  select(`Cell Type`, 
         `Mean (No Metastasis)`, `SD (No Metastasis)`, `Median (No Metastasis)`,
         `Mean (Metastasis)`, `SD (Metastasis)`, `Median (Metastasis)`, `p.value`) %>%
  rename(`p-value` = p.value)

# Create a nicely formatted table with multi-level headers
final_table %>%
  kable(caption = "Summary Statistics and t-test p-values for Cell Type Proportions by Metastasis Status") %>%
  add_header_above(c(" " = 1, "No Metastasis" = 3, "Metastasis" = 3, " " = 1)) %>%
  kable_styling(full_width = FALSE)
```

```{r}
# ------------------------------------------------
# Load required packages
# ------------------------------------------------
library(dplyr)      # For data manipulation
library(tibble)     # For column_to_rownames()
library(pheatmap)   # For heatmap visualization

# ------------------------------------------------
# Example: Define cell type variables
# ------------------------------------------------
cell_type_vars <- c("CD8mem", "Bmem", "Treg", "NK", "DC", "Eos",
                    "Endothelial", "Epithelial", "Fib")

# ------------------------------------------------
# 1) Make sure 'combined_data_filtered' has a unique ID column
#    that we can use as row names (e.g., 'SampleID').
# ------------------------------------------------
# Suppose 'combined_data_filtered' has these columns:
#   - SampleID
#   - CD8mem, Bmem, Treg, NK, DC, Eos, Endothelial, Epithelial, Fib
#   - (possibly other columns)
#
# We'll build a matrix 'cell_props' where rownames are SampleIDs
# and columns are the cell-type variables.

cell_props <- combined_data_filtered %>%
  # Select the ID column plus the cell type columns
  select(SampleID, all_of(cell_type_vars)) %>%
  # Convert 'SampleID' from a column into row names
  column_to_rownames("SampleID")

# ------------------------------------------------
# 2) Scale the cell-type proportions
# ------------------------------------------------
scaled_props <- scale(cell_props)

# ------------------------------------------------
# 3) Hierarchical clustering
# ------------------------------------------------
dist_mat <- dist(scaled_props, method = "euclidean")
hc <- hclust(dist_mat, method = "ward.D2")

# ------------------------------------------------
# 4) Define clusters (k=2) and label them
# ------------------------------------------------
clusters <- cutree(hc, k = 2)
# Convert numeric cluster labels to a factor with meaningful names
cell_props$Cluster <- factor(clusters,
                             levels = c(1, 2),
                             labels = c("Immune Cold", "Immune Hot"))

# ------------------------------------------------
# 5) Build the row annotation data frame
# ------------------------------------------------
annotation_row <- data.frame(Cluster = cell_props$Cluster)

# Ensure row names match exactly with 'scaled_props'
# That means we assign the same row names to annotation_row:
rownames(annotation_row) <- rownames(cell_props)

# Just to be safe, drop any unused factor levels
annotation_row$Cluster <- droplevels(annotation_row$Cluster)

# Verify that the row names of 'scaled_props' match 'annotation_row'
stopifnot(identical(rownames(scaled_props), rownames(annotation_row)))

# ------------------------------------------------
# 6) Define annotation colors
# ------------------------------------------------
# pheatmap will look for a list where the key = "Cluster"
# and the values are named by the factor levels in 'annotation_row$Cluster'
annotation_colors <- list(
  Cluster = c("Immune Cold" = "blue",
              "Immune Hot"  = "red")
)

# ------------------------------------------------
# 7) Plot with pheatmap
# ------------------------------------------------
pheatmap(scaled_props,
         cluster_rows      = hc,
         cluster_cols      = TRUE,
         clustering_method = "ward.D2",
         annotation_row    = annotation_row,
         annotation_colors = annotation_colors,
         main = "Cell Type Proportion Clustering (Immune Hot vs. Cold)")

# ------------------------------------------------
# 8) (Optional) Bar plot of cluster membership
# ------------------------------------------------
cat("Cluster Membership Counts:\n")
print(table(cell_props$Cluster))
```

```{r}
# ------------------------------------------------
# Load required packages
# ------------------------------------------------
library(dplyr)      # For data manipulation
library(tibble)     # For column_to_rownames()
library(pheatmap)   # For heatmap visualization

# ------------------------------------------------
# Example: Define cell type variables
# ------------------------------------------------
cell_type_vars <- c("CD8mem", "Bmem", "Treg", "NK", "DC", "Eos",
                    "Endothelial", "Epithelial", "Fib")

# ------------------------------------------------
# 1) Create cell_props from combined_data_filtered with SampleID as rownames
# ------------------------------------------------
cell_props <- combined_data_filtered %>%
  select(SampleID, all_of(cell_type_vars)) %>%
  column_to_rownames("SampleID")

# ------------------------------------------------
# 2) Scale the cell-type proportions
# ------------------------------------------------
scaled_props <- scale(cell_props)
# ------------------------------------------------
# 3) Hierarchical clustering
# ------------------------------------------------
dist_mat <- dist(scaled_props, method = "euclidean")
hc <- hclust(dist_mat, method = "ward.D2")

# ------------------------------------------------
# 4) Define clusters (k=2) and label them
# ------------------------------------------------
clusters <- cutree(hc, k = 2)
# Convert numeric cluster labels to a factor with meaningful names
cell_props$Cluster <- factor(clusters, levels = c(1, 2),
                             labels = c("Immune Hot", "Immune Cold"))

# ------------------------------------------------
# 5) Build the row annotation data frame with both Cluster and Metastasis Status
# ------------------------------------------------
# Use metastasis status from combined_data_filtered; assume it is currently coded as "FALSE"/"TRUE"
annotation_row <- data.frame(
  Cluster = as.character(cell_props$Cluster),
  Metastasis = combined_data_filtered$any_mets
)
rownames(annotation_row) <- rownames(cell_props)

# Convert Cluster to a factor and drop unused levels
annotation_row$Cluster <- factor(annotation_row$Cluster)
annotation_row$Cluster <- droplevels(annotation_row$Cluster)

# Convert Metastasis to a factor with meaningful labels:
annotation_row$Metastasis <- factor(annotation_row$Metastasis,
                                    levels = c("FALSE", "TRUE"),
                                    labels = c("No Metastasis", "Metastasis"))
annotation_row$Metastasis <- droplevels(annotation_row$Metastasis)

# ------------------------------------------------
# 6) Define annotation colors for both columns
# ------------------------------------------------
annotation_colors <- list(
  Cluster = c("Immune Cold" = "blue", "Immune Hot" = "red"),
  Metastasis = c("No Metastasis" = "green", "Metastasis" = "purple")
)

# ------------------------------------------------
# 7) Order the rows by metastasis status so that similar statuses appear together
# ------------------------------------------------
order_idx <- order(annotation_row$Metastasis)
scaled_props_ordered <- scaled_props[order_idx, ]
annotation_row_ordered <- annotation_row[order_idx, ]

# ------------------------------------------------
# 8) Plot the heatmap with pheatmap (disabling row clustering to preserve the ordering)
# ------------------------------------------------
pheatmap(scaled_props_ordered,
         cluster_rows = FALSE,
         cluster_cols = TRUE,
         annotation_row = annotation_row_ordered,
         annotation_colors = annotation_colors,
         main = "Cell Type Proportion Clustering\n(Ordered by Metastasis Status)")

# ------------------------------------------------
# 9) (Optional) Display cluster membership counts and average cell type proportions per cluster
# ------------------------------------------------
cat("Cluster Membership Counts:\n")
print(table(cell_props$Cluster))

cluster_means <- cell_props %>%
  group_by(Cluster) %>%
  summarise(across(where(is.numeric), mean, na.rm = TRUE))
print(cluster_means)

```

Recreating Figure 6 from Oncogenic RAS Signaling Promotes Tumor Immunoresistance by Stabilizing PD-L1 mRNA

```{r}
# ----------------------------------------------------
# Load required packages
# ----------------------------------------------------
library(dplyr)
library(tidyr)
library(pheatmap)

# ----------------------------------------------------
# 1) Define Genes of Interest
# ----------------------------------------------------
immune_genes <- c("IFNGR1", "F2RL1", "CD274", "SOCS1", "PSEN1", "SLC11A1",
                  "RPS6", "TP53", "IL12RB1", "CD1C", "PSEN2", "EOMES",
                  "CD1D", "TIGIT", "PTPRC", "LCP1", "IL18R1", "CD3E")

# ----------------------------------------------------
# 2) Filter Annotation to Find CpGs for These Genes
# ----------------------------------------------------
df_anno <- as.data.frame(anno) 
df_immune <- df_anno %>%
  filter(grepl(paste(immune_genes, collapse = "|"), UCSC_RefGene_Name, ignore.case = TRUE))
immune_cpgs <- unique(df_immune$Name)
immune_cpgs <- immune_cpgs[immune_cpgs %in% rownames(DH_CRC_M_value_filtered)]

# ----------------------------------------------------
# 3) Subset Your Methylation Matrix
# ----------------------------------------------------
#immune_matrix <- DH_CRC_M_value_filtered[immune_cpgs, , drop = FALSE]
immune_matrix <- DH_CRC_Betas[immune_cpgs, , drop = FALSE]

# ----------------------------------------------------
# 4) Create Row Annotation Mapping Each CpG to Its Gene
# ----------------------------------------------------
row_anno_df <- df_immune %>%
  select(Name, UCSC_RefGene_Name) %>%
  distinct() %>%
  filter(Name %in% immune_cpgs)
row_anno_df$Gene <- sapply(strsplit(row_anno_df$UCSC_RefGene_Name, ";"), `[`, 1)
rownames(row_anno_df) <- row_anno_df$Name
row_anno_df <- row_anno_df["Gene"]

# ----------------------------------------------------
# 5) Prepare combined_data_filtered for Column Annotation
# ----------------------------------------------------
# Ensure combined_data_filtered has a 'SampleID' column
if (!"SampleID" %in% colnames(combined_data_filtered)) {
  stop("combined_data_filtered must have a 'SampleID' column")
}
# --------------------------
# Step 2: Filter out Rectal Samples
# --------------------------
combined_data_filtered <- combined_data 
# --------------------------
# Step 3: Normalize Metadata Columns
# --------------------------
combined_data_filtered <- combined_data_filtered %>%
  mutate(
    site = tolower(gsub(" ", "", site)),
    across(c("sex", "any_mets", "MLH1", "Distant_Mets", "ln_only", "node_stage"), as.factor),
    age = as.numeric(as.character(age))
  )

# Define the cell-type variables of interest.
cell_type_vars <- c("Tumor", "Endothelial", "Epithelial", "Fib", "Eos", 
                    "CD8mem", "Bmem", "Treg", "CD4mem", "DC", "NK")

# Rename the outcome levels for clarity: assume any_mets is currently "FALSE" and "TRUE"
combined_data_filtered$any_mets <- factor(combined_data_filtered$any_mets, 
                                          levels = c("FALSE", "TRUE"),
                                          labels = c("No Metastasis", "Metastasis"))

# Get sample IDs from the methylation matrix (they should match the SampleID in combined_data_filtered)
sample_ids <- colnames(immune_matrix)

# Create column annotation by matching sample_ids to the SampleID column in combined_data_filtered
col_anno_df <- data.frame(
  Metastasis = combined_data_filtered$any_mets[match(sample_ids, combined_data_filtered$SampleID)]
)
rownames(col_anno_df) <- sample_ids

# ----------------------------------------------------
# 6) Define Annotation Colors for the Column Annotation
# ----------------------------------------------------
annotation_colors <- list(
  Metastasis = c("No Metastasis" = "green",
                 "Metastasis" = "purple")
)

# ----------------------------------------------------
# 7) Scale Each CpG Row (if desired)
# ----------------------------------------------------
immune_matrix_scaled <- t(scale(t(immune_matrix)))

order_idx <- order(col_anno_df$Metastasis)
immune_matrix_ordered <- immune_matrix_scaled[, order_idx]
col_anno_df_ordered <- col_anno_df[order_idx, , drop = FALSE]

# ----------------------------------------------------
# 8) Generate the Heatmap with pheatmap
# ----------------------------------------------------
pheatmap(
  immune_matrix_ordered,
  annotation_row    = row_anno_df,  # Row annotation with gene names (if desired)
  annotation_col    = col_anno_df,  # Column annotation with metastasis status
  annotation_colors = annotation_colors,
  cluster_rows      = TRUE,
  cluster_cols      = FALSE,
  show_rownames     = FALSE,
  show_colnames     = TRUE,
  annotation_names_col = TRUE,       # Display annotation header for columns
  annotation_legend    = TRUE,       # Ensure the legend is displayed
  main = "Methylation Heatmap of Immune Evasion Genes"
)
```

```{r}
# Load required packages
library(dplyr)
library(tidyr)
library(pheatmap)

# ----------------------------------------------------
# 1) Define Immune Exhaustion Genes of Interest
# ----------------------------------------------------
exhaustion_genes <- c(
  # Inhibitory receptors
  "BTLA", "CD22", "CD274", "CD327", "CTLA4", "FCRL4", "HAVCR2", "LAG3", 
  "LAIR1", "NR4A1", "PDCD1", "PDCD1LG2", "TIGIT", "TRAF1", "VSIR", "VTCN1",
  # Immunosuppressive mediators
  "IDO1", "IFNA1", "IFNB1", "IL6", "IL10", "TGFB1",
  # Transcription factors
  "BATF", "EOMES", "FOXO1", "FOXP1", "NFATC1", "PRDM1", "SIRT1", "TOX", "TOX2", "TBX21"
)

# ----------------------------------------------------
# 2) Filter Annotation for These Genes
# ----------------------------------------------------
# Assume 'anno' is your annotation data frame with columns:
#   - 'Name' (CpG ID)
#   - 'UCSC_RefGene_Name' (gene names, possibly semicolon-separated)
df_anno <- as.data.frame(anno)
df_exhaustion <- df_anno %>%
  filter(grepl(paste(exhaustion_genes, collapse = "|"), UCSC_RefGene_Name, ignore.case = TRUE))
exhaustion_cpgs <- unique(df_exhaustion$Name)
exhaustion_cpgs <- exhaustion_cpgs[exhaustion_cpgs %in% rownames(DH_CRC_M_value_filtered)]

# ----------------------------------------------------
# 3) Subset Your Methylation Matrix to These CpGs
# ----------------------------------------------------
exhaustion_matrix <- DH_CRC_M_value_filtered[exhaustion_cpgs, , drop = FALSE]

# ----------------------------------------------------
# 4) Create Row Annotation Mapping Each CpG to Its Gene
# ----------------------------------------------------
row_anno_df <- df_exhaustion %>%
  select(Name, UCSC_RefGene_Name) %>%
  distinct() %>%
  filter(Name %in% exhaustion_cpgs)
# For CpGs annotated to multiple genes, take the first one.
row_anno_df$Gene <- sapply(strsplit(row_anno_df$UCSC_RefGene_Name, ";"), `[`, 1)
rownames(row_anno_df) <- row_anno_df$Name
# We only need the gene name column for the annotation.
row_anno_df <- row_anno_df["Gene"]

# ----------------------------------------------------
# 5) Create Column Annotation for Metastasis Status
# ----------------------------------------------------
# Ensure combined_data_filtered has a 'SampleID' column and that sample IDs match the column names of the methylation matrix.
if (!"SampleID" %in% colnames(combined_data_filtered)) {
  stop("combined_data_filtered must have a 'SampleID' column")
}
# Convert SampleID to character and set as rownames.
combined_data_filtered <- combined_data_filtered %>%
  mutate(SampleID = as.character(SampleID))
rownames(combined_data_filtered) <- combined_data_filtered$SampleID

# (If needed, filter out unwanted samples; here we assume it’s already been done.)

# Recode any_mets so that "FALSE" becomes "No Metastasis" and "TRUE" becomes "Metastasis"
combined_data_filtered$any_mets <- factor(combined_data_filtered$any_mets,
                                          levels = c("FALSE", "TRUE"),
                                          labels = c("No Metastasis", "Metastasis"))

# Get sample IDs from exhaustion_matrix (columns)
sample_ids <- colnames(exhaustion_matrix)

# Create column annotation by matching sample_ids to the 'any_mets' column.
col_anno_df <- data.frame(
  Metastasis = combined_data_filtered[sample_ids, "any_mets"]
)
rownames(col_anno_df) <- sample_ids
# Explicitly set the column name to "Metastasis"
colnames(col_anno_df) <- "Metastasis"

# Define annotation colors for metastasis
annotation_colors <- list(
  Metastasis = c("No Metastasis" = "green", "Metastasis" = "purple")
)

# ----------------------------------------------------
# 6) Scale Each CpG Row (if desired)
# ----------------------------------------------------
# This transforms each CpG's values into z-scores across samples.
exhaustion_matrix_scaled <- t(scale(t(exhaustion_matrix)))

order_idx <- order(col_anno_df$Metastasis)
exhaustion_matrix_ordered <- exhaustion_matrix_scaled[, order_idx]
col_anno_df_ordered <- col_anno_df[order_idx, , drop = FALSE]
# ----------------------------------------------------
# 7) Generate the Heatmap with pheatmap
# ----------------------------------------------------
pheatmap(
  exhaustion_matrix_ordered,
  annotation_row    = row_anno_df,      # Row annotation: gene names
  annotation_col    = col_anno_df,      # Column annotation: metastasis status
  annotation_colors = annotation_colors,
  cluster_rows      = TRUE,
  cluster_cols      = TRUE,
  show_rownames     = FALSE,            # Change to TRUE if you want to see CpG IDs
  show_colnames     = TRUE,
  annotation_names_col = TRUE,          # Display annotation header for columns
  annotation_legend    = TRUE,          # Ensure the legend is displayed
  main = "Methylation Heatmap of Immune Exhaustion Genes"
)
```

# 1. Extract SNP Probes

```{r include=FALSE}
# Extract TypeSnpI data from the manifest
typeSnpI_data <- get("TypeSnpI", envir = manifest@data)

# Extract TypeSnpII data from the manifest
typeSnpII_data <- get("TypeSnpII", envir = manifest@data)

# Display the first few rows of TypeSnpI data to inspect
head(typeSnpI_data)

# Display the first few rows of TypeSnpII data to inspect
head(typeSnpII_data)

# Extracting rsIDs from both TypeSnpI and TypeSnpII data
snpI_ids <- typeSnpI_data$Name
snpII_ids <- typeSnpII_data$Name

# Combining the rsIDs
combined_snp_ids <- c(snpI_ids, snpII_ids)

# Subsetting the betas matrix using these rsIDs
snp_betas <- DH_CRC_Betas[combined_snp_ids, ]

# Check the dimensions of the snp_betas matrix
dim(snp_betas)
```

Test MsigDB code:

```{r}
library(dplyr)

h_gene_sets_df = msigdbr(species = "human", category = "H")

# If your methylation annotation uses gene SYMBOL:
hallmark_symbol_list <- h_gene_sets_df %>%
  group_by(gs_name) %>%
  summarize(genes = list(unique(gene_symbol)), .groups = "drop") %>%
  # Convert to a named list
  pull(genes) %>%
  setNames(h_gene_sets_df %>% distinct(gs_name) %>% pull(gs_name))

# If your methylation annotation uses ENTREZ IDs:

hallmark_entrez_list <- h_gene_sets_df %>%
  group_by(gs_name) %>%
  summarize(genes = list(unique(as.character(entrez_gene))), .groups = "drop") %>%
  pull(genes) %>%
  setNames(unique(h_gene_sets_df$gs_name))
```

```{r}
library(methylGSA)
hallmark_results_methylGSA <- methylglm(
  cpg.pval  = cpg_pval,
  array.type = "EPIC",             # or "450K"
  group      = "all",              # or "body"/"promoter1"/"promoter2"
  GS.list    = hallmark_entrez_list,  # <--- your custom list here
  GS.idtype  = "ENTREZID",            # must match how your hallmark list is stored
  minsize    = 100,
  maxsize    = 500,
  parallel   = FALSE
  # Notice: we do NOT use GS.type here.
)

head(hallmark_results_methylGSA)
library(ggplot2)
library(dplyr)

# Select the top 5 significant terms (sorted by p-value)
top_terms <- hallmark_results_methylGSA %>%
  arrange(pvalue) %>%
  head(10)

# Convert ID to factor with ordered levels for proper sorting
top_terms$ID <- factor(top_terms$ID, levels = rev(top_terms$ID))

# Create a ggplot barplot
ggplot(top_terms, aes(x = ID, y = Size, fill = pvalue)) +
  geom_bar(stat = "identity") +
  scale_fill_gradient(low = "blue", high = "red") +  # Color by p-value (red = more significant)
  coord_flip() +  # Flip for Enrichr-style horizontal bars
  labs(x = "", y = "Size", title = "Top 5 Enriched Hallmark Pathways (methylGSA)") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        plot.title = element_text(size = 14, face = "bold"))


head(hallmark_results_methylGSA, n =10)
```
